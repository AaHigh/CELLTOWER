<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>CELLTOWER</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{
  width:100%;height:100%;
  max-width:100vw;max-height:100vh;
  background:#000;
  overflow:hidden !important;
  touch-action:none;
  position:fixed;
  top:0;left:0;right:0;bottom:0;
}
canvas#cv{display:block;position:fixed;top:0;left:0;touch-action:none}
</style>
</head>
<body>

</style>
</head>
<body>
<canvas id="cv"></canvas>

<!-- â”€â”€ RECEIPT OVERLAY â€” HTML/CSS for beautiful thermal paper look â”€â”€ -->

<div id="receipt-overlay">
  <div id="receipt-close" onclick="hideReceipt()">âœ• CLOSE</div>
  <div id="receipt-scroll">
    <div id="receipt-paper">
      <div id="receipt-content"></div>
    </div>
  </div>
</div>

<style>
#receipt-overlay{
  position:fixed;top:0;left:0;right:0;bottom:0;
  background:#111;
  z-index:500;
  display:none;
  flex-direction:column;
  align-items:center;
}
#receipt-overlay.show{display:flex}
#receipt-close{
  width:100%;
  padding:12px 16px;
  font-family:'Courier New',monospace;font-size:.8rem;font-weight:900;
  color:#ff8800;background:#000;border-bottom:2px solid #ff8800;
  cursor:pointer;text-align:right;letter-spacing:.12em;flex-shrink:0;
  box-sizing:border-box;
}
#receipt-scroll{
  width:100%;
  flex:1;
  overflow-y:scroll;
  overflow-x:hidden;
  -webkit-overflow-scrolling:touch;
  scroll-behavior:smooth;
  background:#888;
  padding:12px 0 40px 0;
  box-sizing:border-box;
}
#receipt-paper{
  width:92%;
  max-width:420px;
  margin:0 auto;
  background:#f5f0e8;
  position:relative;
  background-image:repeating-linear-gradient(
    180deg,
    transparent 0px, transparent 8px,
    rgba(0,0,0,0.018) 8px, rgba(0,0,0,0.018) 9px
  );
  border-top:2px dashed #c8bfa0;
  border-bottom:2px dashed #c8bfa0;
  box-shadow:2px 2px 12px rgba(0,0,0,0.5);
}
#receipt-content{
  width:100%;
  padding:8px 0;
  box-sizing:border-box;
  background:transparent;
}
#receipt-content canvas{
  width:100% !important;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
  display:block;
}
</style>

<script>
// Error reporter â€” works even if canvas never initializes
window.onerror = function(msg, src, line, col, err) {
  var d = document.getElementById('diag');
  if(d){ d.style.display='block'; d.textContent = 'ERR L'+line+': '+msg+'\n'+(err&&err.stack?err.stack:''); }
  return false;
};
window.addEventListener('unhandledrejection', function(e){
  var d = document.getElementById('diag');
  if(d){ d.style.display='block'; d.textContent += '\nPromise: '+e.reason; }
});
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CELLTOWER â€” single-canvas renderer
// All layout, UI, input handled here. Game logic below is unchanged.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const cv = document.getElementById('cv');
const CTX = cv.getContext('2d');

// â”€â”€ Screen dimensions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let SW, SH;   // screen width/height
var CELL = 20; // tetris cell size â€” also declared by game logic (var hoists safely)

// â”€â”€ Safe defaults for game globals (real values set by game logic) â”€â”€â”€â”€
var score=0, level=1, lines=0, hi=0, dead=false, paused=false;
var board=null, cur=null, cx=0, cy=0, nxt=null;
var placements=null, particles=[], explodedCells=new Set();
var piecePot=0, tetrisPot=0;
var AUTO_PLAY=false, AUTO_SPEED=5, autoUsed=false;
var AT=0;
var playerHasMoved=false, moveStartTime=0;

// â”€â”€ Layout regions (computed in layout()) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let R = {};   // named rects: {x,y,w,h}

// â”€â”€ Game state mirrors (set by game logic, read by renderer) â”€â”€â”€â”€â”€â”€â”€â”€â”€
let ui = {
  score:0, level:1, lines:0, hi:0,
  holes:0, tbClean:0, tbTetris:0,
  tickers:[],          // [{text,hue}]
  prevPlacements:[null,null,null,null],
  showTetris:false,
  tetrisReady:false,   // I-piece loaded
  paused:false,
  dead:false,
  gameStarted:false,   // false = show start screen
  autoOn:false,
  autoUsed:false,
  autoSpeed:5,
  // start screen pulse
  startPulse:0,
  // notification flash
  flash:null,          // {text, until}
  // tower severity
  towerSev:0,
};

// â”€â”€ Fonts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FONT_TITLE = 'bold 900 {S}px monospace';
const FONT_LABEL = '700 {S}px monospace';
const FONT_VAL   = '900 {S}px monospace';
const FONT_SMALL = '600 {S}px monospace';
function F(template, size){ return template.replace('{S}', Math.round(size)); }

// â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const C = {
  bg:      '#080018',
  panel:   'rgba(20,0,40,0.85)',
  border:  '#5500aa',
  borderHi:'#00ffaa',
  cyan:    '#00ffff',
  yellow:  '#ffff00',
  orange:  '#ff8800',
  red:     '#ff4444',
  purple:  '#aa88ff',
  white:   '#ffffff',
  dimText: '#664488',
  green:   '#00ff88',
  autoBorder: '#00ffaa',
};

// â”€â”€ Touch/hit regions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let hitZones = [];  // [{id, x,y,w,h}]

function addHit(id, x, y, w, h){
  hitZones.push({id, x:Math.round(x), y:Math.round(y), w:Math.round(w), h:Math.round(h)});
}

// â”€â”€ Resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resize(){
  // Use documentElement.clientWidth/Height â€” these exclude scrollbars
  // and give true viewport size on iOS Safari
  SW = document.documentElement.clientWidth  || window.innerWidth  || 390;
  SH = document.documentElement.clientHeight || window.innerHeight || 844;
  cv.width  = SW;
  cv.height = SH;
  cv.style.width  = SW + 'px';
  cv.style.height = SH + 'px';
  computeLayout();
}

function computeLayout(){
  hitZones = [];

  // Fixed proportions that work on any phone:
  // Left info col | Playfield | Right info col
  // Piece buttons row
  // Control buttons row
  // Auto row

  const PAD = Math.round(SW * 0.02);
  const GAP = Math.round(SW * 0.015);

  // Control row at bottom: 6 round buttons
  const CTRL_H = Math.round(SH * 0.085);
  const CTRL_Y = SH - CTRL_H - PAD;

  // Auto row above controls
  const AUTO_H = Math.round(SH * 0.055);
  const AUTO_Y = CTRL_Y - AUTO_H - GAP;

  // Piece selector row above auto
  const PIECE_H = Math.round(SH * 0.10);
  const PIECE_Y = AUTO_Y - PIECE_H - GAP;

  // Title bar
  const TITLE_H = Math.round(SH * 0.045);
  const TITLE_Y = PAD;

  // Main area between title and piece row
  const MAIN_Y = TITLE_Y + TITLE_H + GAP;
  const MAIN_H = PIECE_Y - MAIN_Y - GAP;

  // Side panels: fixed width
  const SIDE_W = Math.round(SW * 0.175);

  // Playfield in center
  const PF_W = SW - 2*SIDE_W - 2*GAP - 2*PAD;
  const PF_X = PAD + SIDE_W + GAP;

  // CELL size
  CELL = Math.floor(Math.min(PF_W / 10, MAIN_H / 25));
  if(CELL < 8) CELL = 8;
  const GW = CELL * 10;
  const GH = CELL * 25;

  // Center the playfield vertically in MAIN area
  const GX = Math.round(PF_X + (PF_W - GW)/2);
  const GY = MAIN_Y + Math.round((MAIN_H - GH)/2);

  R = {
    title:  {x:PAD, y:TITLE_Y, w:SW-2*PAD, h:TITLE_H},
    // Left panel boxes
    lScore: {x:PAD, y:MAIN_Y,                          w:SIDE_W, h:Math.round(MAIN_H*0.18)},
    lLevel: {x:PAD, y:MAIN_Y+Math.round(MAIN_H*0.20), w:SIDE_W, h:Math.round(MAIN_H*0.18)},
    lLines: {x:PAD, y:MAIN_Y+Math.round(MAIN_H*0.40), w:SIDE_W, h:Math.round(MAIN_H*0.18)},
    lTicker:{x:PAD, y:MAIN_Y+Math.round(MAIN_H*0.60), w:SIDE_W, h:Math.round(MAIN_H*0.40)},
    // Right panel boxes
    rNext:  {x:SW-PAD-SIDE_W, y:MAIN_Y,                          w:SIDE_W, h:Math.round(MAIN_H*0.22)},
    rHi:    {x:SW-PAD-SIDE_W, y:MAIN_Y+Math.round(MAIN_H*0.24), w:SIDE_W, h:Math.round(MAIN_H*0.14)},
    rPause: {x:SW-PAD-SIDE_W, y:MAIN_Y+Math.round(MAIN_H*0.40), w:SIDE_W, h:Math.round(MAIN_H*0.14)},
    rTBonus:{x:SW-PAD-SIDE_W, y:MAIN_Y+Math.round(MAIN_H*0.56), w:SIDE_W, h:Math.round(MAIN_H*0.22)},
    rHoles: {x:SW-PAD-SIDE_W, y:MAIN_Y+Math.round(MAIN_H*0.80), w:SIDE_W, h:Math.round(MAIN_H*0.18)},
    // Playfield
    gx: GX, gy: GY, gw: GW, gh: GH,
    // Piece row
    pieces: {x:PAD, y:PIECE_Y, w:SW-2*PAD, h:PIECE_H},
    // Controls row
    ctrl:   {x:PAD, y:CTRL_Y,  w:SW-2*PAD, h:CTRL_H},
    // Auto row
    auto:   {x:PAD, y:AUTO_Y,  w:SW-2*PAD, h:AUTO_H},
    PAD, GAP, SIDE_W,
    PIECE_Y, PIECE_H, CTRL_Y, CTRL_H, AUTO_Y, AUTO_H,
    MAIN_Y, MAIN_H,
  };

  // Register hit zones
  addHit('pause',  R.rPause.x, R.rPause.y, R.rPause.w, R.rPause.h);

  const PW = Math.round((R.pieces.w - 3*GAP) / 4);
  for(let i=0;i<4;i++){
    addHit('piece'+i, R.pieces.x + i*(PW+GAP), R.pieces.y, PW, R.pieces.h);
  }

  const CBW = Math.round((R.ctrl.w - 5*GAP) / 6);
  const cbIds = ['rotl','left','soft','hard','right','rotr'];
  for(let i=0;i<6;i++){
    addHit('ctrl_'+cbIds[i], R.ctrl.x + i*(CBW+GAP), R.ctrl.y, CBW, R.ctrl.h);
  }

  // Auto row: [AUTO toggle] [====slider====] [speed val] [RECEIPT]
  const AUTO_BTN_W = Math.round(R.auto.w * 0.25);
  const RECEIPT_W  = Math.round(R.auto.w * 0.25);
  addHit('auto_toggle', R.auto.x, R.auto.y, AUTO_BTN_W, R.auto.h);
  addHit('receipt',     R.auto.x + R.auto.w - RECEIPT_W, R.auto.y, RECEIPT_W, R.auto.h);
  // Slider zone
  const SLX = R.auto.x + AUTO_BTN_W + GAP;
  const SLW = R.auto.w - AUTO_BTN_W - RECEIPT_W - 2*GAP;
  addHit('speed_slider', SLX, R.auto.y, SLW, R.auto.h);
  R.sliderX = SLX; R.sliderW = SLW;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function roundRect(x,y,w,h,r){
  CTX.beginPath();
  CTX.moveTo(x+r,y);
  CTX.lineTo(x+w-r,y); CTX.quadraticCurveTo(x+w,y,x+w,y+r);
  CTX.lineTo(x+w,y+h-r); CTX.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  CTX.lineTo(x+r,y+h); CTX.quadraticCurveTo(x,y+h,x,y+h-r);
  CTX.lineTo(x,y+r); CTX.quadraticCurveTo(x,y,x+r,y);
  CTX.closePath();
}

function panel(x,y,w,h, borderColor){
  roundRect(x,y,w,h, 6);
  CTX.fillStyle = C.panel;
  CTX.fill();
  CTX.strokeStyle = borderColor || C.border;
  CTX.lineWidth = 1.5;
  CTX.stroke();
}

function label(text, x, y, w, color, size){
  CTX.font = F(FONT_LABEL, size||10);
  CTX.fillStyle = color || C.purple;
  CTX.textAlign = 'center';
  CTX.textBaseline = 'top';
  CTX.fillText(text, x + w/2, y);
}

function val(text, x, y, w, color, size){
  CTX.font = F(FONT_VAL, size||14);
  CTX.fillStyle = color || C.cyan;
  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';
  CTX.shadowColor = color || C.cyan;
  CTX.shadowBlur = 6;
  CTX.fillText(text, x + w/2, y);
  CTX.shadowBlur = 0;
}

function infoBox(r, labelText, valueText, valColor, labelSize, valSize){
  panel(r.x, r.y, r.w, r.h);
  const lh = r.h * 0.38;
  label(labelText, r.x, r.y + r.h*0.08, r.w, C.purple, labelSize || Math.max(7, r.h*0.22));
  val(valueText,   r.x, r.y + r.h*0.65, r.w, valColor || C.cyan, valSize || Math.max(10, r.h*0.35));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CELL DRAWING (3D bevel, same as old cell3d)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawCell(ctx, x, y, s, rgb, t){
  if(!rgb) return;
  const [r,g,b] = rgb;
  // Base fill
  ctx.fillStyle = `rgb(${r},${g},${b})`;
  ctx.fillRect(x+1, y+1, s-2, s-2);
  // Top/left highlight
  const hl = Math.min(255, r+80);
  const hg = Math.min(255, g+80);
  const hb = Math.min(255, b+80);
  ctx.fillStyle = `rgba(${hl},${hg},${hb},0.6)`;
  ctx.fillRect(x+1, y+1, s-2, 2);
  ctx.fillRect(x+1, y+1, 2, s-2);
  // Bottom/right shadow
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(x+1, y+s-3, s-2, 2);
  ctx.fillRect(x+s-3, y+1, 2, s-2);
  // Pulse outline
  if(t !== undefined){
    const pulse = 0.4 + 0.3*Math.sin(t*3 + r*0.01);
    ctx.strokeStyle = `rgba(${r},${g},${b},${pulse})`;
    ctx.lineWidth = 0.5;
    ctx.strokeRect(x+0.5, y+0.5, s-1, s-1);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN DRAW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Debug log â€” small green overlay at bottom, auto-clears old entries
let _dbgLines = [];
function dbg(msg){}
function drawDebug(){
  if(!_dbgLines.length) return;
  const lh=13, pad=4, h=_dbgLines.length*lh+pad*2;
  CTX.fillStyle='rgba(0,0,0,0.8)';
  CTX.fillRect(0,SH-h,SW,h);
  CTX.font='10px monospace'; CTX.textAlign='left'; CTX.textBaseline='top';
  _dbgLines.forEach((line,i)=>{
    CTX.fillStyle=line.startsWith('ERR')?'#ff4444':'#00ff88';
    CTX.fillText(line, pad, SH-h+pad+i*lh);
  });
}

function draw(ts){
  if(!SW||!SH||!R.gw) return; // layout not ready yet
  const t = ts * 0.001;

  // Background
  const bg = CTX.createLinearGradient(0,0,SW,SH);
  bg.addColorStop(0,'#080018'); bg.addColorStop(1,'#050015');
  CTX.fillStyle = bg;
  CTX.fillRect(0,0,SW,SH);

  drawTitle(t);

  if(!ui.gameStarted){
    drawStartScreen(t);
  } else {
    drawLeftPanel(t);
    drawRightPanel(t);
    drawPlayfield(t);
    drawPieceRow(t);
    drawAutoRow(t);
    drawControlRow(t);
    if(paused) drawPauseOverlay();
    if(dead)   drawGameOverOverlay();
  }

  if(_receiptOpen) drawReceiptOverlay(t);
  if(ui.flash && ts < ui.flash.until) drawFlash(t);
  // drawDebug();
}

// â”€â”€ Title â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawTitle(t){
  const r = R.title;
  const sz = Math.max(12, r.h * 0.75);
  CTX.save();
  CTX.font = F('900 {S}px monospace', sz);
  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';
  // Rainbow gradient
  const grd = CTX.createLinearGradient(r.x, 0, r.x+r.w, 0);
  grd.addColorStop(0,'#ff00ff');
  grd.addColorStop(0.3,'#00ffff');
  grd.addColorStop(0.6,'#ffff00');
  grd.addColorStop(1,'#ff00aa');
  CTX.fillStyle = grd;
  CTX.shadowColor = '#ff00ff';
  CTX.shadowBlur = 10;
  CTX.fillText('âœ¦ CELLTOWER âœ¦', SW/2, r.y + r.h/2);
  CTX.restore();
}

// â”€â”€ Start screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawStartScreen(t){
  const bx = R.gx, by = R.gy, bw = R.gw, bh = R.gh;
  const mx = bx + bw/2;

  // CELLTOWER rainbow title inside box
  const tsz = Math.max(14, bw * 0.09);
  CTX.font = F('900 {S}px monospace', tsz);
  CTX.textAlign = 'center';
  CTX.textBaseline = 'middle';
  const grd = CTX.createLinearGradient(bx,0,bx+bw,0);
  grd.addColorStop(0,'#ff00ff'); grd.addColorStop(0.5,'#00ffff'); grd.addColorStop(1,'#ffff00');
  CTX.fillStyle = grd;
  CTX.shadowColor='#ff00ff'; CTX.shadowBlur=12;
  CTX.fillText('âœ¦ CELLTOWER âœ¦', mx, by + bh*0.18);
  CTX.shadowBlur=0;

  // by Aaron Hightower
  CTX.font = F('600 {S}px monospace', Math.max(8, bw*0.055));
  CTX.fillStyle = '#aa88ff';
  CTX.fillText('by Aaron Hightower', mx, by + bh*0.30);

  // TAP TO PLAY button
  const btnW = bw * 0.78, btnH = bh * 0.14;
  const btnX = mx - btnW/2, btnY = by + bh*0.40;
  const pulse = 0.7 + 0.3*Math.sin(t*2.5);
  const grdBtn = CTX.createLinearGradient(btnX,0,btnX+btnW,0);
  grdBtn.addColorStop(0,`rgba(170,0,255,${pulse})`);
  grdBtn.addColorStop(1,`rgba(255,0,170,${pulse})`);
  roundRect(btnX, btnY, btnW, btnH, 10);
  CTX.fillStyle = grdBtn; CTX.fill();
  CTX.strokeStyle=`rgba(255,255,255,${pulse*0.5})`; CTX.lineWidth=1; CTX.stroke();

  CTX.font = F('900 {S}px monospace', Math.max(10, btnH*0.38));
  CTX.fillStyle = '#fff';
  CTX.shadowColor='#fff'; CTX.shadowBlur=8;
  CTX.fillText('TAP TO PLAY', mx, btnY + btnH/2);
  CTX.shadowBlur=0;

  // Register hit zone for TAP TO PLAY
  hitZones = hitZones.filter(z=>z.id!=='start');
  addHit('start', btnX, btnY, btnW, btnH);

  // Hint text
  CTX.font = F('500 {S}px monospace', Math.max(7, bw*0.045));
  CTX.fillStyle = '#664488';
  CTX.fillText('AUTO available after start', mx, by + bh*0.63);
  CTX.fillText('AUTO scores: no high score', mx, by + bh*0.70);
}

// â”€â”€ Left panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawLeftPanel(t){
  infoBox(R.lScore, 'SCORE', String(score), C.cyan);
  infoBox(R.lLevel, 'LEVEL', String(level), C.cyan);
  infoBox(R.lLines, 'LINES', String(lines), C.cyan);
  drawTicker(t);
}

function drawTicker(t){
  const r = R.lTicker;
  panel(r.x, r.y, r.w, r.h);
  const n = ui.tickers.length;
  if(n===0) return;
  // Fixed compact line height â€” fit as many rows as possible
  const lineH = Math.max(9, Math.min(18, r.h / 12));
  const fontSize = Math.max(6, lineH * 0.72);
  CTX.font = F(FONT_SMALL, fontSize);
  CTX.textAlign = 'right';
  CTX.textBaseline = 'middle';
  // Show as many rows as fit, newest at bottom
  const maxVisible = Math.floor(r.h / lineH);
  const start = Math.max(0, n - maxVisible);
  for(let i=start; i<n; i++){
    const item = ui.tickers[i];
    const age = n - 1 - i;  // 0=newest, increases for older
    // Luminance only: newest=full white, fades to dim for older entries
    const lum = Math.max(35, 95 - age * 8);
    CTX.fillStyle = `hsl(0,0%,${lum}%)`;
    CTX.shadowColor = 'rgba(0,0,0,0.5)';
    CTX.shadowBlur = 2;
    const iy = r.y + r.h - (n - i) * lineH + lineH / 2;
    if(iy > r.y && iy < r.y + r.h)
      CTX.fillText(item.text, r.x + r.w - 3, iy);
  }
  CTX.shadowBlur = 0;
}

// â”€â”€ Right panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRightPanel(t){
  drawNextPiece(t);
  infoBox(R.rHi,    'HIGH',  String(hi),    C.cyan);
  drawPauseBox(t);
  drawTBonusBox(t);
  infoBox(R.rHoles, 'HOLES', String(ui.holes), C.red);
}

function drawNextPiece(t){
  const r = R.rNext;
  panel(r.x, r.y, r.w, r.h);
  label('NEXT', r.x, r.y + r.h*0.05, r.w, C.purple, Math.max(7,r.h*0.15));
  if(!nxt) return;
  const cc = nxt.c;
  const s = Math.min(Math.floor(r.w*0.7/Math.max(cc.length,cc[0].length)), Math.floor(r.h*0.65/cc.length));
  const ox = r.x + (r.w - cc[0].length*s)/2;
  const oy = r.y + r.h*0.28 + (r.h*0.65 - cc.length*s)/2;
  for(let row=0;row<cc.length;row++)
    for(let col=0;col<cc[row].length;col++)
      if(cc[row][col]) drawCell(CTX, ox+col*s, oy+row*s, s, nxt.rgb, t);
}

function drawPauseBox(t){
  const r = R.rPause;
  panel(r.x, r.y, r.w, r.h, paused ? C.cyan : C.border);
  label('PAUSE', r.x, r.y+r.h*0.08, r.w, C.purple, Math.max(7,r.h*0.22));
  val('â¸', r.x, r.y+r.h*0.65, r.w, paused ? C.cyan : C.white, Math.max(10,r.h*0.35));
}

function drawTBonusBox(t){
  const r = R.rTBonus;
  panel(r.x, r.y, r.w, r.h);
  label('T-BONUS', r.x, r.y+r.h*0.04, r.w, C.purple, Math.max(6,r.h*0.14));
  const lsz = Math.max(7, r.h*0.17);
  const vsz = Math.max(8, r.h*0.20);
  CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.font = F(FONT_SMALL, lsz);
  CTX.fillStyle=C.cyan; CTX.fillText('CLEAN:', r.x+r.w/2, r.y+r.h*0.38);
  CTX.font = F(FONT_VAL, vsz);
  CTX.fillStyle=C.yellow;
  CTX.shadowColor=C.yellow; CTX.shadowBlur=6;
  CTX.fillText(String(piecePot ? Math.round(piecePot/100) : 0), r.x+r.w/2, r.y+r.h*0.55);
  CTX.font = F(FONT_SMALL, lsz);
  CTX.fillStyle=C.cyan; CTX.fillText('TETRIS:', r.x+r.w/2, r.y+r.h*0.72);
  CTX.font = F(FONT_VAL, vsz);
  CTX.fillStyle=C.orange;
  CTX.shadowColor=C.orange;
  CTX.fillText(String(tetrisPot ? Math.round(tetrisPot/100) : 0), r.x+r.w/2, r.y+r.h*0.88);
  CTX.shadowBlur=0;
}

// â”€â”€ Playfield â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPlayfield(t){
  const gx = R.gx, gy = R.gy, gw = R.gw, gh = R.gh;

  // Background
  const bg2 = CTX.createLinearGradient(gx,gy,gx+gw,gy+gh);
  bg2.addColorStop(0,'#080018'); bg2.addColorStop(1,'#050015');
  CTX.fillStyle=bg2; CTX.fillRect(gx,gy,gw,gh);

  // Grid lines
  CTX.strokeStyle='rgba(80,0,160,0.25)'; CTX.lineWidth=0.5;
  for(let r=0;r<=25;r++){
    CTX.beginPath(); CTX.moveTo(gx,gy+r*CELL); CTX.lineTo(gx+gw,gy+r*CELL); CTX.stroke();
  }
  for(let c=0;c<=10;c++){
    CTX.beginPath(); CTX.moveTo(gx+c*CELL,gy); CTX.lineTo(gx+c*CELL,gy+gh); CTX.stroke();
  }

  // Locked cells
  if(board){
    for(let r=0;r<25;r++) for(let c=0;c<10;c++){
      if(board[r][c] && !explodedCells.has(`${r},${c}`))
        drawCell(CTX, gx+c*CELL, gy+r*CELL, CELL, board[r][c], t);
    }
  }

  // Explosion particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.07; p.life-=p.decay;
    if(p.life<=0){particles.splice(i,1);continue;}
    CTX.globalAlpha=p.life;
    CTX.fillStyle=`rgb(${p.r},${p.g},${p.b})`;
    CTX.fillRect(gx+p.x, gy+p.y, p.sz, p.sz);
  }
  CTX.globalAlpha=1;

  // Ghost + current piece
  if(cur && !dead && placements){
    CTX.save();
    CTX.beginPath(); CTX.rect(gx,gy,gw,gh); CTX.clip();
    drawGhosts(t, gx, gy);
    // Current piece
    for(let r=0;r<cur.c.length;r++) for(let c=0;c<cur.c[r].length;c++){
      if(cur.c[r][c]) drawCell(CTX, gx+(cx+c)*CELL, gy+(cy+r)*CELL, CELL, cur.rgb, t);
    }
    CTX.restore();
  }

  // Pulsing border
  const pulse2 = 0.25 + 0.5*(0.5+0.5*Math.sin(t*Math.PI*0.5));
  const bw2 = Math.ceil(CELL*0.15);
  CTX.save();
  CTX.strokeStyle=`rgba(255,220,0,${pulse2})`;
  CTX.lineWidth=bw2;
  CTX.shadowColor=`rgba(255,200,0,${pulse2*0.6})`;
  CTX.shadowBlur=bw2*2;
  CTX.strokeRect(gx+bw2/2, gy+bw2/2, gw-bw2, gh-bw2);
  CTX.restore();

  // READY/status text in bottom-left of playfield
  drawPlayfieldStatus(t, gx, gy, gw, gh);
}

function drawGhosts(t, gx, gy){
  if(!placements) return;
  const elapsed = AT - moveStartTime;

  for(let i=0;i<placements.length;i++){
    const p = placements[i];
    if(!p) continue;

    // Fade logic
    let alpha;
    if(!playerHasMoved){ alpha=0.38; }
    else if(elapsed<0.5){ alpha = (i===0 && p.fpKey===_straightFp) ? 0.38 : 0; }
    else { alpha = 0.38 * Math.min(1, (elapsed-0.5)/0.5); }
    if(alpha <= 0) continue;

    // Use the falling piece's own color â€” ghost is a very dim version of it
    const [r0,g0,b0] = cur ? cur.rgb : [100,100,100];

    CTX.save();

    // Ghost rendering: transparent fill (piece color tinted) + pure white outline
    // Outer silhouette = exposed edges only, pure white at 75% alpha
    // Interior dividers = thinner white at 37% alpha (half of outer)
    // Even placements slightly brighter than odd to delineate adjacent ghosts
    const outAlpha = (i % 2 === 0) ? 0.90 : 0.55;
    const lw = Math.max(2, CELL * 0.2);  // 2x thicker

    // Transparent fill â€” piece color at very low opacity so shape reads without blocking
    CTX.globalAlpha = alpha * 0.18;
    CTX.fillStyle = `rgb(${r0},${g0},${b0})`;
    for(let r=0;r<p.c.length;r++) for(let c=0;c<p.c[r].length;c++){
      if(!p.c[r][c]) continue;
      CTX.fillRect(gx+(p.x+c)*CELL+1, gy+(p.dropY+r)*CELL+1, CELL-2, CELL-2);
    }

    // Outer silhouette: pure white, exposed edges only
    CTX.globalAlpha = alpha * outAlpha;
    CTX.strokeStyle = '#ffffff';
    CTX.lineWidth = lw;
    for(let r=0;r<p.c.length;r++) for(let c=0;c<p.c[r].length;c++){
      if(!p.c[r][c]) continue;
      const px2 = gx + (p.x+c)*CELL;
      const py2 = gy + (p.dropY+r)*CELL;
      const hasUp    = r>0 && p.c[r-1][c];
      const hasDown  = r<p.c.length-1 && p.c[r+1] && p.c[r+1][c];
      const hasLeft  = c>0 && p.c[r][c-1];
      const hasRight = c<p.c[r].length-1 && p.c[r][c+1];
      CTX.beginPath();
      if(!hasUp)    { CTX.moveTo(px2,      py2);      CTX.lineTo(px2+CELL, py2); }
      if(!hasDown)  { CTX.moveTo(px2,      py2+CELL); CTX.lineTo(px2+CELL, py2+CELL); }
      if(!hasLeft)  { CTX.moveTo(px2,      py2);      CTX.lineTo(px2,      py2+CELL); }
      if(!hasRight) { CTX.moveTo(px2+CELL, py2);      CTX.lineTo(px2+CELL, py2+CELL); }
      CTX.stroke();
    }

    // Interior cell dividers: pure white, half alpha, thinner
    CTX.globalAlpha = alpha * outAlpha * 0.5;
    CTX.lineWidth = Math.max(0.5, lw * 0.5);
    for(let r=0;r<p.c.length;r++) for(let c=0;c<p.c[r].length;c++){
      if(!p.c[r][c]) continue;
      const px2 = gx + (p.x+c)*CELL;
      const py2 = gy + (p.dropY+r)*CELL;
      const hasUp    = r>0 && p.c[r-1][c];
      const hasDown  = r<p.c.length-1 && p.c[r+1] && p.c[r+1][c];
      const hasLeft  = c>0 && p.c[r][c-1];
      const hasRight = c<p.c[r].length-1 && p.c[r][c+1];
      CTX.beginPath();
      if(hasUp)    { CTX.moveTo(px2,      py2);      CTX.lineTo(px2+CELL, py2); }
      if(hasDown)  { CTX.moveTo(px2,      py2+CELL); CTX.lineTo(px2+CELL, py2+CELL); }
      if(hasLeft)  { CTX.moveTo(px2,      py2);      CTX.lineTo(px2,      py2+CELL); }
      if(hasRight) { CTX.moveTo(px2+CELL, py2);      CTX.lineTo(px2+CELL, py2+CELL); }
      CTX.stroke();
    }

    // Number badge centered on bounding box
    let minR=99,maxR=0,minC=99,maxC=0;
    for(let r=0;r<p.c.length;r++) for(let c=0;c<p.c[r].length;c++){
      if(p.c[r][c]){minR=Math.min(minR,r);maxR=Math.max(maxR,r);minC=Math.min(minC,c);maxC=Math.max(maxC,c);}
    }
    // True nearest-point snap: find centroid, then find closest point
    // in the set of filled-cell centers. If two cells are equidistant,
    // the average of their centers is used â€” landing on the midpoint between them.
    const rawCX = (minC + maxC) / 2 + 0.5;
    const rawCY = (minR + maxR) / 2 + 0.5;
    // Collect all filled cell centers and their distances to centroid
    const filled = [];
    for(let r=0;r<p.c.length;r++) for(let c=0;c<p.c[r].length;c++){
      if(!p.c[r][c]) continue;
      const fx = c + 0.5, fy = r + 0.5;
      const d = (fx-rawCX)**2 + (fy-rawCY)**2;
      filled.push({fx, fy, d});
    }
    // Find minimum distance
    const minD = filled.reduce((m,f)=>Math.min(m,f.d), Infinity);
    // Gather all cells at (approximately) that distance â€” tolerance for float equality
    const tol = minD * 0.01 + 0.0001;
    const nearest = filled.filter(f => f.d <= minD + tol);
    // Average their centers â€” if one cell, lands on its center;
    // if two equidistant, lands on their midpoint
    const avgX = nearest.reduce((s,f)=>s+f.fx,0) / nearest.length;
    const avgY = nearest.reduce((s,f)=>s+f.fy,0) / nearest.length;
    const numX = gx + (p.x + avgX) * CELL;
    const numY = gy + (p.dropY + avgY) * CELL;
    const numSz = Math.max(14, CELL*1.2);  // large but 20% reduced

    CTX.globalAlpha = Math.min(1, alpha * 1.6);
    CTX.font = `900 ${Math.round(numSz)}px "Arial Black","Impact",sans-serif`;
    CTX.textAlign = 'center';
    CTX.textBaseline = 'middle';
    CTX.shadowBlur = 0;

    // Drop shadow: semi-transparent black, offset 1 stroke-width right+down
    const dropOff = Math.max(1, Math.round(numSz * 0.08));
    CTX.fillStyle = 'rgba(0,0,0,0.6)';
    CTX.fillText(String(i+1), numX + dropOff, numY + dropOff);

    // White number on top
    CTX.fillStyle = '#ffffff';
    CTX.fillText(String(i+1), numX, numY);

    CTX.restore();
  }
}

let _straightFp = null; // set by calcPlacements

function drawPlayfieldStatus(t, gx, gy, gw, gh){
  if(!ui.gameStarted || dead) return;
  const sz = Math.max(7, CELL*0.55);
  CTX.font = F(FONT_SMALL, sz);
  CTX.textAlign='left'; CTX.textBaseline='bottom';
  CTX.fillStyle='#00ff88'; CTX.shadowColor='#00ff88'; CTX.shadowBlur=4;
  // Show last ticker item as status
  if(ui.tickers.length>0){
    const last = ui.tickers[ui.tickers.length-1];
    CTX.fillText(last.text, gx+4, gy+gh-4);
  }
  CTX.shadowBlur=0;
}

// â”€â”€ Piece row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPieceRow(t){
  const r = R.pieces;
  const GAP = R.GAP;
  const PW = Math.round((r.w - 3*GAP) / 4);

  // Same colors as ghost pieces on playfield
  const SLOT_COLORS = [
    [180, 60, 255],
    [255, 200, 0],
    [0, 220, 180],
    [255, 80, 120],
  ];

  for(let i=0;i<4;i++){
    const px = r.x + i*(PW+GAP);
    const py = r.y;
    // Use the current piece color â€” all slots same hue, consistent with ghosts
    const [rc,gc,bc] = cur ? cur.rgb : [120,120,120];
    const isSelected = (placements && placements[i] && selectedPlacementIdx===i);
    const borderColor = isSelected ? `rgb(${rc},${gc},${bc})` : C.border;
    panel(px, py, PW, r.h, borderColor);

    const p = placements ? placements[i] : null;
    if(p && cur){
      const cc = p.c;
      const s = Math.min(Math.floor(PW*0.65/Math.max(cc[0].length,4)), Math.floor(r.h*0.65/cc.length));
      if(s < 2) continue;

      // Center the piece in the button, leaving room for number at bottom
      const pieceW = cc[0].length * s;
      const pieceH = cc.length * s;
      const ox = px + (PW - pieceW)/2;
      const oy = py + (r.h - pieceH)/2 - s*0.3; // shift slightly up

      // Match ghost rendering: transparent color fill + pure white outline
      // Transparent fill â€” piece color hint
      CTX.fillStyle = `rgb(${rc},${gc},${bc})`;
      CTX.globalAlpha = 0.18;
      for(let row=0;row<cc.length;row++) for(let col=0;col<cc[row].length;col++){
        if(!cc[row][col]) continue;
        CTX.fillRect(ox+col*s+1, oy+row*s+1, s-2, s-2);
      }

      // Outer silhouette: pure white exposed edges
      CTX.globalAlpha = 0.75;
      CTX.strokeStyle = '#ffffff';
      CTX.lineWidth = Math.max(1, s * 0.1);
      for(let row=0;row<cc.length;row++) for(let col=0;col<cc[row].length;col++){
        if(!cc[row][col]) continue;
        const cx2 = ox+col*s, cy2 = oy+row*s;
        const hU = row>0 && cc[row-1][col];
        const hD = row<cc.length-1 && cc[row+1] && cc[row+1][col];
        const hL = col>0 && cc[row][col-1];
        const hR = col<cc[row].length-1 && cc[row][col+1];
        CTX.beginPath();
        if(!hU){ CTX.moveTo(cx2,   cy2);   CTX.lineTo(cx2+s, cy2); }
        if(!hD){ CTX.moveTo(cx2,   cy2+s); CTX.lineTo(cx2+s, cy2+s); }
        if(!hL){ CTX.moveTo(cx2,   cy2);   CTX.lineTo(cx2,   cy2+s); }
        if(!hR){ CTX.moveTo(cx2+s, cy2);   CTX.lineTo(cx2+s, cy2+s); }
        CTX.stroke();
      }

      // Interior dividers: white at half alpha
      CTX.globalAlpha = 0.38;
      CTX.lineWidth = Math.max(0.5, s * 0.05);
      for(let row=0;row<cc.length;row++) for(let col=0;col<cc[row].length;col++){
        if(!cc[row][col]) continue;
        const cx2 = ox+col*s, cy2 = oy+row*s;
        const hU = row>0 && cc[row-1][col];
        const hD = row<cc.length-1 && cc[row+1] && cc[row+1][col];
        const hL = col>0 && cc[row][col-1];
        const hR = col<cc[row].length-1 && cc[row][col+1];
        CTX.beginPath();
        if(hU){ CTX.moveTo(cx2,   cy2);   CTX.lineTo(cx2+s, cy2); }
        if(hD){ CTX.moveTo(cx2,   cy2+s); CTX.lineTo(cx2+s, cy2+s); }
        if(hL){ CTX.moveTo(cx2,   cy2);   CTX.lineTo(cx2,   cy2+s); }
        if(hR){ CTX.moveTo(cx2+s, cy2);   CTX.lineTo(cx2+s, cy2+s); }
        CTX.stroke();
      }
      CTX.globalAlpha = 1;

      // Number â€” centered on piece, dark circle background
      // Find bounding center
      let minR=99,maxR=0,minC2=99,maxC2=0;
      for(let row=0;row<cc.length;row++) for(let col=0;col<cc[row].length;col++){
        if(cc[row][col]){minR=Math.min(minR,row);maxR=Math.max(maxR,row);minC2=Math.min(minC2,col);maxC2=Math.max(maxC2,col);}
      }
      // True nearest-point snap for button
      const rawBX = (minC2 + maxC2) / 2 + 0.5;
      const rawBY = (minR  + maxR)  / 2 + 0.5;
      const bfilled = [];
      for(let row=0;row<cc.length;row++) for(let col=0;col<cc[row].length;col++){
        if(!cc[row][col]) continue;
        const fx = col + 0.5, fy = row + 0.5;
        const d = (fx-rawBX)**2 + (fy-rawBY)**2;
        bfilled.push({fx, fy, d});
      }
      const bminD = bfilled.reduce((m,f)=>Math.min(m,f.d), Infinity);
      const btol = bminD * 0.01 + 0.0001;
      const bnearest = bfilled.filter(f => f.d <= bminD + btol);
      const bavgX = bnearest.reduce((s,f)=>s+f.fx,0) / bnearest.length;
      const bavgY = bnearest.reduce((s,f)=>s+f.fy,0) / bnearest.length;
      const numX = ox + bavgX * s;
      const numY = oy + bavgY * s;
      const numSz = Math.max(10, s*1.2);  // match ghost proportion

      const btnDrop = Math.max(1, Math.round(numSz * 0.08));
      CTX.font = `900 ${Math.round(numSz)}px "Arial Black","Impact",sans-serif`;
      CTX.textAlign = 'center';
      CTX.textBaseline = 'middle';
      CTX.shadowBlur = 0;

      // Drop shadow first
      CTX.fillStyle = 'rgba(0,0,0,0.6)';
      CTX.fillText(String(i+1), numX + btnDrop, numY + btnDrop);

      // White number on top
      CTX.fillStyle = '#ffffff';
      CTX.fillText(String(i+1), numX, numY);
    } else {
      // Empty slot â€” just show number in corner
      CTX.font = F(FONT_SMALL, Math.max(8, PW*0.18));
      CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
      CTX.fillStyle = C.dimText;
      CTX.fillText(String(i+1), px+PW/2, py+r.h/2);
    }
  }

  // TETRIS button â€” spans full width if active
  if(ui.showTetris){
    const TY = r.y - r.h*0.3 - R.GAP;
    const TH = r.h*0.3;
    const pulse3 = 0.6 + 0.4*Math.sin(t*4);
    roundRect(r.x, TY, r.w, TH, 6);
    CTX.fillStyle=`rgba(0,200,255,${pulse3*0.3})`; CTX.fill();
    CTX.strokeStyle=`rgba(0,200,255,${pulse3})`; CTX.lineWidth=1.5; CTX.stroke();
    CTX.font=F(FONT_LABEL, Math.max(8,TH*0.5));
    CTX.textAlign='center'; CTX.textBaseline='middle';
    CTX.fillStyle=`rgba(0,255,255,${pulse3})`;
    CTX.fillText('TETRIS â€” tap to clear 4 lines', r.x+r.w/2, TY+TH/2);
    hitZones = hitZones.filter(z=>z.id!=='tetris');
    addHit('tetris', r.x, TY, r.w, TH);
  }
}


let selectedPlacementIdx = -1;

// â”€â”€ Control row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CTRL_LABELS = ['â†º','â—€','â–¼','â¬‡','â–¶','â†»'];
const CTRL_IDS = ['rotl','left','soft','hard','right','rotr'];
let ctrlPressed = {};  // id -> true while held

function drawControlRow(t){
  const r = R.ctrl;
  const GAP = R.GAP;
  const CBW = Math.round((r.w - 5*GAP) / 6);
  for(let i=0;i<6;i++){
    const id = CTRL_IDS[i];
    const bx = r.x + i*(CBW+GAP);
    const by = r.y;
    const pressed = ctrlPressed[id];
    const rad = Math.min(CBW,r.h)/2;
    CTX.beginPath();
    CTX.arc(bx+CBW/2, by+r.h/2, rad*0.9, 0, Math.PI*2);
    CTX.fillStyle = pressed ? 'rgba(0,150,255,0.7)' : 'rgba(0,60,150,0.85)';
    CTX.fill();
    CTX.strokeStyle = pressed ? C.cyan : '#3366cc';
    CTX.lineWidth = 1.5;
    CTX.stroke();
    CTX.font=F(FONT_LABEL, Math.max(10, rad*0.8));
    CTX.textAlign='center'; CTX.textBaseline='middle';
    CTX.fillStyle=C.white;
    CTX.fillText(CTRL_LABELS[i], bx+CBW/2, by+r.h/2);
  }
}

// â”€â”€ Auto row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawAutoRow(t){
  const r = R.auto;
  const GAP = R.GAP;
  const AUTO_BTN_W = Math.round(r.w * 0.25);
  const RECEIPT_W  = Math.round(r.w * 0.25);

  // AUTO toggle button
  const isOn = AUTO_PLAY;
  panel(r.x, r.y, AUTO_BTN_W, r.h, isOn ? C.autoBorder : C.border);
  const asz = Math.max(7, r.h*0.32);
  CTX.font=F(FONT_LABEL, asz);
  CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillStyle = isOn ? C.green : C.purple;
  if(isOn){CTX.shadowColor=C.green; CTX.shadowBlur=8;}
  CTX.fillText('ğŸ¤– AUTO', r.x + AUTO_BTN_W/2, r.y + r.h/2);
  CTX.shadowBlur=0;
  if(isOn){
    const dotR=3;
    CTX.beginPath(); CTX.arc(r.x+AUTO_BTN_W-8, r.y+r.h/2, dotR, 0, Math.PI*2);
    CTX.fillStyle=C.green; CTX.fill();
  }

  // Speed slider
  const SLX = r.x + AUTO_BTN_W + GAP;
  const SLW = R.sliderW;
  const SLY = r.y + r.h/2;
  const sliderH = 5;
  CTX.fillStyle='rgba(85,0,170,0.8)';
  roundRect(SLX, SLY-sliderH/2, SLW, sliderH, 3);
  CTX.fill();
  const frac = (AUTO_SPEED-1)/10;
  CTX.fillStyle='#ff00ff';
  roundRect(SLX, SLY-sliderH/2, SLW*frac, sliderH, 3);
  CTX.fill();
  // Thumb
  const thumbX = SLX + SLW*frac;
  CTX.beginPath(); CTX.arc(thumbX, SLY, 8, 0, Math.PI*2);
  CTX.fillStyle=C.yellow; CTX.fill();
  // Speed value
  const speedLabelX = SLX + SLW + GAP + 14;
  CTX.font=F(FONT_VAL, Math.max(8,r.h*0.40));
  CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillStyle=C.yellow; CTX.shadowColor=C.yellow; CTX.shadowBlur=4;
  CTX.fillText(String(AUTO_SPEED), speedLabelX, SLY);
  CTX.shadowBlur=0;

  // RECEIPT button
  const RX = r.x + r.w - RECEIPT_W;
  panel(RX, r.y, RECEIPT_W, r.h, '#aa6600');
  CTX.font=F(FONT_SMALL, Math.max(7,r.h*0.32));
  CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillStyle='#ffcc44';
  CTX.fillText('ğŸ§¾ RECEIPT', RX+RECEIPT_W/2, r.y+r.h/2);
}

// â”€â”€ Pause overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPauseOverlay(){
  CTX.fillStyle='rgba(0,0,0,0.6)';
  CTX.fillRect(R.gx, R.gy, R.gw, R.gh);
  CTX.font=F(FONT_TITLE, Math.max(16, R.gw*0.1));
  CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillStyle=C.cyan; CTX.shadowColor=C.cyan; CTX.shadowBlur=15;
  CTX.fillText('â¸ PAUSED', R.gx+R.gw/2, R.gy+R.gh/2);
  CTX.shadowBlur=0;
}

// â”€â”€ Game over overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawGameOverOverlay(){
  CTX.fillStyle='rgba(0,0,0,0.78)';
  roundRect(R.gx, R.gy, R.gw, R.gh, 6); CTX.fill();

  const mx=R.gx+R.gw/2, my=R.gy;
  const bh=R.gh;

  CTX.textAlign='center';
  CTX.font=F(FONT_TITLE, Math.max(14,R.gw*0.10));
  CTX.fillStyle='#ff4444'; CTX.shadowColor='#ff4444'; CTX.shadowBlur=10;
  CTX.fillText('GAME OVER', mx, my+bh*0.20);
  CTX.shadowBlur=0;

  const qualifier = autoUsed ? 'Â· AUTO Â·' : (score>=hi && score>0 ? 'â˜… NEW HIGH â˜…':'');
  CTX.font=F(FONT_LABEL, Math.max(9,R.gw*0.065));
  CTX.fillStyle=C.cyan;
  CTX.fillText('Score: '+score, mx, my+bh*0.34);
  if(qualifier){
    CTX.fillStyle=autoUsed?C.orange:C.yellow;
    CTX.shadowColor=CTX.fillStyle; CTX.shadowBlur=8;
    CTX.fillText(qualifier, mx, my+bh*0.44);
    CTX.shadowBlur=0;
  }

  // PLAY AGAIN button
  const bw3=R.gw*0.72, bh3=bh*0.13;
  const bx3=mx-bw3/2, by3=my+bh*0.56;
  const grdBtn=CTX.createLinearGradient(bx3,0,bx3+bw3,0);
  grdBtn.addColorStop(0,'#aa00ff'); grdBtn.addColorStop(1,'#ff00aa');
  roundRect(bx3,by3,bw3,bh3,8); CTX.fillStyle=grdBtn; CTX.fill();
  // Auto-fit font so text never exceeds button width
  let paFontSz = Math.max(8, bh3*0.38);
  CTX.font=F(FONT_VAL, paFontSz);
  while(CTX.measureText('PLAY AGAIN').width > bw3*0.85 && paFontSz > 8){
    paFontSz -= 1; CTX.font=F(FONT_VAL, paFontSz);
  }
  CTX.fillStyle='#fff'; CTX.shadowColor='#fff'; CTX.shadowBlur=6;
  CTX.fillText('PLAY AGAIN', mx, by3+bh3/2);
  CTX.shadowBlur=0;

  hitZones=hitZones.filter(z=>z.id!=='playagain');
  addHit('playagain', bx3, by3, bw3, bh3);
}

// â”€â”€ Flash notification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawFlash(t){
  if(!ui.flash) return;
  CTX.font=F(FONT_VAL, Math.max(12,SW*0.05));
  CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillStyle='#fff'; CTX.shadowColor='#ffff00'; CTX.shadowBlur=20;
  CTX.fillText(ui.flash.text, SW/2, SH*0.5);
  CTX.shadowBlur=0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RECEIPT OVERLAY (full canvas)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let _receiptOpen = false;

function drawReceiptOverlay(t){
  CTX.fillStyle='rgba(2,8,2,0.96)';
  CTX.fillRect(0,0,SW,SH);
  CTX.fillStyle='#1a1a1a';
  const rw=Math.min(SW*0.9,400), rx=(SW-rw)/2;
  roundRect(rx,40,rw,SH-80,6); CTX.fill();
  CTX.strokeStyle='#333'; CTX.lineWidth=1; CTX.stroke();

  // Close button
  panel(SW-60, 44, 52, 32, '#444');
  CTX.font=F(FONT_SMALL,12); CTX.textAlign='center'; CTX.textBaseline='middle';
  CTX.fillStyle='#aaa'; CTX.fillText('âœ• CLOSE', SW-34, 60);
  hitZones=hitZones.filter(z=>z.id!=='receipt_close');
  addHit('receipt_close', SW-60, 44, 52, 32);

  // Receipt content
  CTX.font=F(FONT_SMALL, 10);
  CTX.textAlign='left'; CTX.textBaseline='top';
  CTX.fillStyle='#00ff00';
  let ry=80; const rlh=14;
  CTX.font='700 11px "Courier New",monospace';
  CTX.fillText('â•â•â• CELLTOWER RECEIPT â•â•â•', rx+10, ry); ry+=rlh*1.5;
  CTX.font='10px "Courier New",monospace';
  CTX.fillText(`Score:    ${score}`, rx+10, ry); ry+=rlh;
  CTX.fillText(`High:     ${hi}`, rx+10, ry); ry+=rlh;
  CTX.fillText(`Level:    ${level}`, rx+10, ry); ry+=rlh;
  CTX.fillText(`Lines:    ${lines}`, rx+10, ry); ry+=rlh;
  CTX.fillText(`Auto:     ${autoUsed?'YES (no hi score)':'NO'}`, rx+10, ry); ry+=rlh*1.5;
  if(txLog && txLog.length>0){
    CTX.font='700 10px "Courier New",monospace';
    CTX.fillStyle='#00ff00';
    CTX.fillText('â”€â”€â”€ EVENTS â”€â”€â”€', rx+10, ry); ry+=rlh;
    CTX.font='9px "Courier New",monospace';
    const start = Math.max(0,txLog.length-20);
    for(let i=start;i<txLog.length&&ry<SH-90;i++){
      const e=txLog[i];
      if(e.type&&e.amount){
        CTX.fillStyle='#00cc00';
        CTX.fillText(`${e.type}: +${e.amount}`, rx+10, ry); ry+=rlh;
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let _sliderDragging=false;

function hitTest(tx, ty){
  for(let i=hitZones.length-1;i>=0;i--){
    const z=hitZones[i];
    if(tx>=z.x && tx<=z.x+z.w && ty>=z.y && ty<=z.y+z.h) return z.id;
  }
  return null;
}

function handleTap(tx, ty){
  const id=hitTest(tx,ty);
  if(!id) return;
  switch(id){
    case 'start':     startGame(); break;
    case 'playagain': restart(); break;
    case 'pause':     if(ui.gameStarted&&!dead) togglePause(); break;
    case 'piece0': case 'piece1': case 'piece2': case 'piece3':
      choose(parseInt(id[5])); break;
    case 'tetris':    chooseTetris(); break;
    case 'ctrl_rotl': rot(-1); break;
    case 'ctrl_rotr': rot(1); break;
    case 'ctrl_soft': sdrop(); break;
    case 'ctrl_hard': hdrop(); break;
    case 'ctrl_left': mhz(-1); break;
    case 'ctrl_right':mhz(1);  break;
    case 'auto_toggle': if(ui.gameStarted&&!dead) toggleAutoPlay(); break;
    case 'receipt':        showReceipt(); break;
    case 'receipt_close':  hideReceipt(); break;
    case 'speed_slider': break; // handled by drag
  }
}

function handleSlider(tx){
  const frac = Math.max(0, Math.min(1, (tx - R.sliderX) / R.sliderW));
  const spd = 1 + Math.round(frac * 10);
  setAutoSpeed(spd);
}

// Hold-repeat for left/right
let _holdId=null, _holdIv=null;
function startHold(id){
  stopHold();
  _holdId=id;
  handleTap(0,0); // won't match - call direct
  // direct call
  if(id==='ctrl_left') mhz(-1);
  else if(id==='ctrl_right') mhz(1);
  _holdIv=setInterval(()=>{
    if(id==='ctrl_left') mhz(-1);
    else if(id==='ctrl_right') mhz(1);
  },80);
}
function stopHold(){
  clearInterval(_holdIv); _holdIv=null; _holdId=null;
}

cv.addEventListener('touchstart', function(e){
  e.preventDefault();
  for(let t of e.changedTouches){
    const tx=t.clientX, ty=t.clientY;
    // If game not started, any tap starts it
    if(!ui.gameStarted){ startGame(); return; }
    const id=hitTest(tx,ty);
    if(id==='ctrl_left'||id==='ctrl_right'){
      ctrlPressed[id.replace('ctrl_','')]=true;
      startHold(id);
    } else if(id==='speed_slider'){
      _sliderDragging=true;
      handleSlider(tx);
    } else {
      handleTap(tx,ty);
      if(id&&id.startsWith('ctrl_')) ctrlPressed[id.replace('ctrl_','')]=true;
    }
  }
},{passive:false});

cv.addEventListener('touchmove', function(e){
  e.preventDefault();
  if(_sliderDragging){
    handleSlider(e.changedTouches[0].clientX);
  }
},{passive:false});

cv.addEventListener('touchend', function(e){
  e.preventDefault();
  _sliderDragging=false;
  stopHold();
  ctrlPressed={};
},{passive:false});

cv.addEventListener('touchcancel', function(e){
  _sliderDragging=false; stopHold(); ctrlPressed={};
},{passive:false});

// Mouse fallback (desktop)
cv.addEventListener('mousedown', function(e){
  if(!ui.gameStarted){ startGame(); return; }
  const id=hitTest(e.clientX,e.clientY);
  if(id==='speed_slider'){ _sliderDragging=true; handleSlider(e.clientX); return; }
  if(id==='ctrl_left'||id==='ctrl_right'){ startHold(id); return; }
  handleTap(e.clientX, e.clientY);
});
cv.addEventListener('mousemove', function(e){
  if(_sliderDragging) handleSlider(e.clientX);
});
cv.addEventListener('mouseup',   function(e){ _sliderDragging=false; stopHold(); ctrlPressed={}; });

// Keyboard
document.addEventListener('keydown', function(e){
  if(e.key==='ArrowLeft')  mhz(-1);
  else if(e.key==='ArrowRight') mhz(1);
  else if(e.key==='ArrowDown')  sdrop();
  else if(e.key==='ArrowUp'||e.key==='z') rot(-1);
  else if(e.key==='x') rot(1);
  else if(e.key===' ') hdrop();
  else if(e.key==='p'||e.key==='P') togglePause();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERING STUB FUNCTIONS called by game logic
// These update the ui{} state object â€” actual drawing happens in draw()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// nc/nx_ stubs â€” game logic calls drawNext() which we handle in draw()
// We just need nc as a dummy canvas so getContext doesn't throw
const nc = document.createElement('canvas');
nc.width=60; nc.height=60;
const nx_ = nc.getContext('2d');
// gc stubs â€” playfiled is R.gx/gy, but game logic uses gc.width etc
const gc = {width:200, height:500};  // updated in layout
const gx = null; // game logic should not use gx directly after our rewrite

// updateHoleDisplay is defined in game logic below â€” it sets ui.holes directly
function updateTBDisplay(){
  ui.tbClean  = piecePot  !== undefined ? Math.round(piecePot)  : 0;
  ui.tbTetris = tetrisPot !== undefined ? Math.round(tetrisPot) : 0;
}
function hideTetrisButton(){ ui.showTetris=false; hitZones=hitZones.filter(z=>z.id!=='tetris'); }
function showTetrisButton(){ ui.showTetris=true; }
function drawNext(){ /* handled in draw() */ }
function drawPrevBtn(idx, p){
  if(!placements) return;
  // placements array is read directly in drawPieceRow
}

// Ticker
const _TICKER_MAX = 14;  // more rows visible
function _tickerInit(){
  ui.tickers=[];
}
function tickerPush(words){
  if(!Array.isArray(words)) words=[words];
  const text = words.join(' ');
  const hue = Math.random()*360;
  ui.tickers.push({text, hue});
  if(ui.tickers.length>_TICKER_MAX) ui.tickers.shift();
}

// _syncAutoUI is defined in game logic below

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYOUT UPDATE â€” keep gc.width/height in sync for game logic
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function layout(){
  resize(); // recomputes R and CELL
  gc.width  = R.gw;
  gc.height = R.gh;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


function loop(ts){
  try{
    AT = ts*0.001;
    draw(ts);
  }catch(e){
    dbg('ERR loop: '+e.message);
    // Also show on canvas directly
    CTX.fillStyle='#900'; CTX.fillRect(0,0,SW||390,80);
    CTX.fillStyle='#fff'; CTX.font='bold 11px monospace';
    CTX.textAlign='left'; CTX.textBaseline='top';
    CTX.fillText('ERR: '+(e.message||e), 4, 4);
    if(e.stack) CTX.fillText(e.stack.split('\n').slice(0,3).join(' | '), 4, 20);
  }
  requestAnimationFrame(loop);
}

// suppress cross-origin noise
window.onerror=function(msg,src,line){ if(!line||line===0)return true; return false; };
window.addEventListener('unhandledrejection',function(e){ e.preventDefault(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME LOGIC (preserved intact from previous version)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ DOM STUBS â”€â”€ game logic calls getElementById â€” we intercept all of these
(function setupDOMStubs(){
  // Offscreen canvas factory â€” returned for any canvas-related getElementById
  function makeCanvas(){
    const c = document.createElement('canvas');
    c.width = 2; c.height = 2;
    return c;
  }

  // Generic absorb-all element stub (for non-canvas DOM ops)
  function makeStub(tag){
    return {
      style:     new Proxy({}, {get:()=>()=>{}, set:()=>true}),
      classList: {toggle:()=>{}, add:()=>{}, remove:()=>{}, contains:()=>false},
      get textContent(){ return ''; },
      set textContent(v){
        if(tag==='sv')  { try{score =parseInt(v)||0;}catch(e){} }
        if(tag==='hv')  { try{hi    =parseInt(v)||0;}catch(e){} }
        if(tag==='lv')  { try{level =parseInt(v)||1;}catch(e){} }
        if(tag==='lnv') { try{lines =parseInt(v)||0;}catch(e){} }
      },
      get innerHTML(){ return ''; },
      set innerHTML(v){},
      appendChild:()=>{},
      removeChild:()=>{},
      scrollTop: 0,
      scrollHeight: 0,
      offsetWidth: 0, offsetHeight: 0,
      getBoundingClientRect: ()=>({top:0,left:0,bottom:0,right:0,width:0,height:0}),
      addEventListener:()=>{},
      removeEventListener:()=>{},
      querySelectorAll:()=>[],
      querySelector:()=>null,
      parentNode: null,
    };
  }

  const _cache = {};
  const _origGet = document.getElementById.bind(document);

  document.getElementById = function(id){
    const real = _origGet(id);
    if(real) return real;
    if(!_cache[id]){
      // Return an offscreen canvas for known canvas IDs
      const canvasIds = ['ticker-canvas','receipt-canvas','pc0','pc1','pc2','pc3'];
      _cache[id] = canvasIds.includes(id) ? makeCanvas() : makeStub(id);
    }
    return _cache[id];
  };

  const _origQS = document.querySelector.bind(document);
  document.querySelector = function(sel){
    return _origQS(sel) || makeStub(sel);
  };
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


const COLS=10,ROWS=25;
const NES_SC=[0,40,100,300,1200];
const NES_SP=[800,717,633,550,467,383,300,217,133,100,83,83,83,67,67,67,50,50,50,33,33,33,33,33,33,33,33,33,33,17];

// â”€â”€â”€ NES RIGHT-HANDED ROTATION SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// All 4 rotation states pre-defined per piece exactly as NES Tetris uses them.
// Rotation index 0 = spawn orientation.
// J/L/T/S/Z rotate around the center cell of their 3Ã—3 bounding box.
// I rotates between horizontal (1 row) and vertical (4 rows, right-biased).
// O has one state only.
const NRS={
  I:[
    [[1,1,1,1]],                          // 0: horizontal
    [[1],[1],[1],[1]],                     // 1: vertical
    [[1,1,1,1]],                          // 2: same as 0
    [[1],[1],[1],[1]]                      // 3: same as 1
  ],
  O:[
    [[1,1],[1,1]],
    [[1,1],[1,1]],
    [[1,1],[1,1]],
    [[1,1],[1,1]]
  ],
  T:[
    [[0,1,0],[1,1,1]],                    // 0: flat, stem up
    [[1,0],[1,1],[1,0]],                  // 1: stem right
    [[1,1,1],[0,1,0]],                    // 2: stem down
    [[0,1],[1,1],[0,1]]                   // 3: stem left
  ],
  S:[
    [[0,1,1],[1,1,0]],                    // 0: horizontal
    [[1,0],[1,1],[0,1]],                  // 1: vertical
    [[0,1,1],[1,1,0]],                    // 2: same as 0
    [[1,0],[1,1],[0,1]]                   // 3: same as 1
  ],
  Z:[
    [[1,1,0],[0,1,1]],                    // 0: horizontal
    [[0,1],[1,1],[1,0]],                  // 1: vertical
    [[1,1,0],[0,1,1]],                    // 2: same as 0
    [[0,1],[1,1],[1,0]]                   // 3: same as 1
  ],
  J:[
    [[1,0,0],[1,1,1]],                    // 0: flat, stem top-left
    [[1,1],[1,0],[1,0]],                  // 1: stem right
    [[1,1,1],[0,0,1]],                    // 2: stem bottom-right
    [[0,1],[0,1],[1,1]]                   // 3: stem left
  ],
  L:[
    [[0,0,1],[1,1,1]],                    // 0: flat, stem top-right
    [[1,0],[1,0],[1,1]],                  // 1: stem right
    [[1,1,1],[1,0,0]],                    // 2: stem bottom-left
    [[1,1],[0,1],[0,1]]                   // 3: stem left
  ]
};

// NES-accurate pivot x-correction applied after rotating from rotâ†’nextRot.
// Keeps visual center of rotation at block index 1 (second from left).
// Only I-piece needs correction: horiz(w=4)â†’vert(w=1) and back.
const PIVOT_DX={
  I:  [1, -1, 1, -1],   // rot0â†’1: +1,  rot1â†’2: -1,  rot2â†’3: +1,  rot3â†’0: -1
  O:  [0,  0, 0,  0],
  T:  [0,  0, 0,  0],
  S:  [0,  0, 0,  0],
  Z:  [0,  0, 0,  0],
  J:  [0,  0, 0,  0],
  L:  [0,  0, 0,  0],
};

// PTYPES used for color lookup and initial shape
const PTYPES={
  I:{c:NRS.I[0],rgb:[0,230,230]},
  O:{c:NRS.O[0],rgb:[230,230,0]},
  T:{c:NRS.T[0],rgb:[180,0,180]},
  S:{c:NRS.S[0],rgb:[0,220,0]},
  Z:{c:NRS.Z[0],rgb:[220,0,0]},
  J:{c:NRS.J[0],rgb:[0,80,220]},
  L:{c:NRS.L[0],rgb:[230,120,0]}
};
const PK=Object.keys(PTYPES);

// â”€â”€â”€ AUDIO ENGINE â€” Clean 8-bit NES chip-tune â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let AC=null;
function getAC(){if(!AC)AC=new(window.AudioContext||window.webkitAudioContext)();return AC;}

let _master=null;
function getMaster(){
  if(!_master){
    const ac=getAC();
    _master=ac.createGain();_master.gain.value=0.36;
    _master.connect(ac.destination);
  }
  return _master;
}

// Core chip-tone â€” pure square/triangle, exponential decay (no dirty tail)
// Uses Web Audio scheduled params so the envelope is sample-accurate
function blip(freq,freq2,dur,vol=0.22,type='square',delayT=0){
  try{
    const ac=getAC();if(ac.state==='suspended')ac.resume();
    const t=ac.currentTime+Math.max(0,delayT);
    const g=ac.createGain();
    g.gain.setValueAtTime(vol,t);
    // Exponential decay â€” mathematically clean, no click/pop at tail
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    const o=ac.createOscillator();o.type=type;
    o.frequency.setValueAtTime(freq,t);
    if(freq2)o.frequency.exponentialRampToValueAtTime(freq2,t+dur*0.8);
    o.connect(g);g.connect(getMaster());
    o.start(t);o.stop(t+dur+0.005);
  }catch(e){}
}

// â”€â”€ SOUND EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Move L/R â€” short high blip (NES Mario coin feel)
function sndMove(){blip(698,null,0.038,0.16,'square');}

// Rotate â€” two-step ascending chip chirp
function sndRotate(){
  blip(523,null,0.035,0.14,'square');
  blip(784,null,0.035,0.14,'square',0.038);
}

// Piece lock â€” descending square thump
function sndLock(){
  blip(280,100,0.13,0.26,'square');
  blip(220,80,0.11,0.18,'triangle',0.01);
}

// Soft drop â€” tiny tick
function sndSoftDrop(){blip(880,null,0.022,0.12,'square');}

// Hard drop â€” fast downward sweep
function sndHardDrop(){
  blip(440,50,0.14,0.28,'square');
  blip(660,55,0.12,0.2,'square',0.015);
}

// Spawn â€” ascending two-note shimmer
function sndSpawn(){blip(1047,1319,0.055,0.10,'triangle');}

// â”€â”€ BLOCK POP (explosion sound per clearing block) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4 pitches â€” one per row being cleared â€” minor chord voicing (very NES)
// rowRank: 0=bottom row, 3=topmost. step: 0=center, 9=edge (pitch rises outward)
const ROW_PITCHES=[262,330,415,523]; // C4 E4 Ab4 C5
function sndBlockPop(rowRank,step){
  const base=ROW_PITCHES[rowRank%4];
  const f=base*(1+step*0.055); // gentle pitch rise toward edges
  blip(f,null,0.030,0.08,'square');
}

// â”€â”€ LINE CLEAR JINGLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Play AFTER the explosion animation as a resolution flourish
function sndLineClear(n){
  if(n<4){
    sndLineClearReversed(n);
    return;
  }
  // Tetris (4 lines) â€” original ascending fanfare unchanged
  const notes=[[262,0],[330,0.03],[415,0.06],[523,0.09],[659,0.12],
               [784,0.15],[988,0.18],[1319,0.21]];
  notes.forEach(([f,dt])=>blip(f,null,0.09,0.20,'square',dt));
  blip(262,null,0.40,0.22,'square',0.26);
  blip(392,null,0.40,0.20,'square',0.26);
  blip(523,null,0.40,0.18,'square',0.26);
  blip(1047,null,0.35,0.16,'triangle',0.28);
}

// Special Tetris-button blip: ascending 3-note chip chord â†’ silence â†’ punch
// Unique â€” never heard in any other context. Signals "here it comes."
function sndTetrisBlip(){
  // Quick ascending triad
  blip(523,null,0.045,0.28,'square',0);
  blip(659,null,0.045,0.28,'square',0.04);
  blip(784,null,0.045,0.28,'square',0.08);
  // Brief silence then a punchy chord stab
  blip(1047,null,0.10,0.35,'square',0.16);
  blip(784,null,0.10,0.30,'square',0.16);
  blip(523,null,0.10,0.25,'square',0.16);
  // High shimmer tail
  blip(2093,1047,0.18,0.18,'triangle',0.20);
}

// Level up â€” classic NES ascending run
function sndLevelUp(){
  [523,659,784,880,1047,1319].forEach((f,i)=>blip(f,null,0.075,0.18,'square',i*0.065));
}

// Game over â€” descending NES death pattern then long low drone
function sndGameOver(){
  [440,415,370,330,294,247,220].forEach((f,i)=>blip(f,null,0.11,0.20,'triangle',i*0.14));
  blip(110,null,0.55,0.28,'square',1.1);
}

// Sad trombone / "wah-wah" â€” plays when no-hole bonus resets due to a hole
function sndBonusReset(){
  blip(494,null,0.18,0.28,'square',0);
  blip(370,null,0.18,0.24,'square',0.10);
  blip(294,null,0.22,0.22,'square',0.20);
  blip(247,220,0.40,0.26,'triangle',0.32);
  blip(110,null,0.30,0.18,'square',0.55);
}

// Bubble pop â€” hole count decreased (good event, subtle)
function sndBubblePop(){
  const ac=getAC(); if(ac.state==='suspended')ac.resume();
  const t=ac.currentTime;
  const o=ac.createOscillator();
  const g=ac.createGain();
  o.connect(g); g.connect(ac.destination);
  o.type='sine';
  o.frequency.setValueAtTime(900,t);
  o.frequency.exponentialRampToValueAtTime(1400,t+0.04);
  o.frequency.exponentialRampToValueAtTime(300,t+0.10);
  g.gain.setValueAtTime(0.18,t);
  g.gain.exponentialRampToValueAtTime(0.001,t+0.12);
  o.start(t); o.stop(t+0.12);
}

// Scoring disabled â€” lingering mournful sound (too many holes, â‰¥7)
function sndScoringDisabled(){
  const ac=getAC(); if(ac.state==='suspended')ac.resume();
  // Deep descending groan + dissonant overtone
  blip(220,110,0.55,0.90,'sawtooth',0);
  blip(233,116,0.40,0.85,'sawtooth',0.05); // slightly detuned = dissonance
  blip(165,82, 0.50,1.20,'triangle',0.15);
  blip(110,null,0.60,0.80,'square',0.50);
  blip(82, null,0.45,0.60,'sawtooth',0.90);
}

// Reversed line clear jingles for clears 1-3 â€” descending frequencies
function sndLineClearReversed(n){
  const J={
    1:[[1047,0],[784,0.055],[659,0.11],[523,0.17]],
    2:[[988,0],[784,0.05],[659,0.10],[494,0.15],[392,0.20]],
    3:[[1047,0],[784,0.04],[659,0.08],[523,0.12],[415,0.16],[330,0.20]],
  };
  const notes=J[Math.min(n,3)]||J[1];
  notes.forEach(([f,dt])=>blip(f,null,0.09,0.20,'square',dt));
}

// â”€â”€ NO-HOLE FANFARE sounds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Basic no-hole achievement â€” shimmery ascending choir-like arp
function sndNoHole(){
  const ac=getAC();if(ac.state==='suspended')ac.resume();
  // Bright ascending pentatonic sparkle
  [523,659,784,1047,1319,1568].forEach((f,i)=>blip(f,null,0.14,0.22,'triangle',i*0.07));
  // Lush sustained chord
  blip(262,null,0.55,0.18,'triangle',0.5);
  blip(392,null,0.55,0.16,'triangle',0.5);
  blip(523,null,0.55,0.15,'triangle',0.5);
  blip(784,null,0.45,0.12,'triangle',0.52);
}

// Perfect-square board â€” eerie "waiting for Tetris" drone
// Low mysterious pulse + rising sine sweep suggests tension/anticipation
function sndWaitingTetris(){
  const ac=getAC();if(ac.state==='suspended')ac.resume();
  // Low pulsing drone â€” like holding breath
  blip(110,55,1.2,0.30,'square',0);
  blip(147,null,0.8,0.18,'square',0.1);
  // Mysterious rising sweep
  blip(220,880,1.0,0.22,'triangle',0.3);
  // Tense high overtone
  blip(1760,880,0.6,0.10,'triangle',0.6);
  // Final anticipation chord
  blip(330,null,0.4,0.20,'square',1.1);
  blip(494,null,0.4,0.18,'square',1.1);
  blip(660,null,0.4,0.15,'square',1.15);
}

// Tetris perfection â€” triumphant overlapping fanfare
function sndTetrisPerfection(){
  const ac=getAC();if(ac.state==='suspended')ac.resume();
  // Massive ascending run
  [262,330,392,494,523,659,784,988,1047,1319,1568,2093]
    .forEach((f,i)=>blip(f,null,0.12,0.25,'square',i*0.05));
  // Big chord explosion at top
  [523,659,784,1047,1319].forEach((f,i)=>blip(f,null,0.65,0.28,'square',0.7));
  // Shimmering triangle tail
  blip(2093,null,1.0,0.18,'triangle',0.75);
  blip(2637,null,0.8,0.14,'triangle',0.80);
  // Final triumphant punch
  blip(1047,null,0.40,0.32,'square',1.4);
  blip(784,null,0.40,0.28,'square',1.4);
  blip(523,null,0.40,0.25,'square',1.42);
}

// â”€â”€ HSL helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function hslStr(h,s,l,a=1){return`hsla(${h%360},${s}%,${l}%,${a})`}

// Compact score formatter for ticker: 100â†’+100  1000â†’+1k  32200â†’+32.2k
// Returns plain string (no HTML â€” canvas fillText only)
function fmtK(n){
  const abs=Math.abs(n);
  if(abs>=1000){
    const k=n/1000;
    // 1 decimal if it adds info, else integer
    const s=Number.isInteger(k)?k.toFixed(0):(Math.round(k*10)/10).toString();
    return(n>0?'+':'')+s+'k';
  }
  return(n>0?'+':'')+n.toString();
}

// â”€â”€ TETRIS SCORE OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Shows TETRIS + score, then BONUS + bonus score (if piecePot+tetrisPot>0)
// Letters appear first, values pulse in 0.25s later with rotating hue per letter
function showTetrisScoreOverlay(){} // removed â€” ticker handles it

function updateHoleDisplay(n){
  ui.holes = n;  // canvas renderer reads this
  const el=document.getElementById('holev');
  if(!el)return;
  el.textContent=n;
  el.style.color=n===0?'#00ffaa':n>=7?'#ff0000':'#ff4444';
  el.style.textShadow=n===0?'0 0 8px #00ffaa':n>=7?'0 0 12px #ff0000':'0 0 8px #ff4444';
}

// Award fractional piecePot on 1-3 line clears based on hole count + lines cleared
function awardLineClearBonus(cleared, rowIndices){
  const holes=currentScoringHoles;
  if(cleared>=4)return;

  // Line fraction: 1=25%, 2=50%, 3=75%
  const LINE_FRAC=[0,0.25,0.50,0.75];
  const lineFrac=LINE_FRAC[Math.min(cleared,3)];
  const linePct=[0,25,50,75][Math.min(cleared,3)];

  // Hole fraction lookup â€” 10% reduction per hole, disabled at 10+
  const HOLE_FRAC=[1.0,0.90,0.80,0.70,0.60,0.50,0.40,0.30,0.20,0.10,0];
  const holeFrac=holes>=10?0:(HOLE_FRAC[holes] !== undefined ? HOLE_FRAC[holes] : 0);
  const holePct=Math.round(holeFrac*100);

  if(holeFrac===0){
    if(!scoringDisabledSound){
      scoringDisabledSound=true;
      sndScoringDisabled();
      setTimeout(()=>{scoringDisabledSound=false;},3000);
    }
    showMathOverlay(cleared,holes,piecePot,linePct,holePct,0,rowIndices);
    return;
  }

  const raw=piecePot*lineFrac*holeFrac;
  let award=Math.floor(raw/100)*100;
  if(award===0&&raw>=50)award=100;

  if(award>0){
    score+=award;
    document.getElementById('sv').textContent=score;
    if(!autoUsed && score>hi){hi=score;document.getElementById('hv').textContent=hi;}
    floatTetrisBonus(award);
    // Transaction log
    txScore('line-'+cleared, award, [
      {label:'Piece pot',       value: piecePot},
      {label:'Lines x'+cleared+' ('+linePct+'%)', value: fmtAmt(Math.round(piecePot*lineFrac))},
      {label:'Holes:'+holes+' ('+holePct+'%)', value: fmtAmt(award)},
      {label:'Formula: '+piecePot+' x '+linePct+'% x '+holePct+'%', value:'= '+award},
    ]);
  } else if(holeFrac===0){
    txScore('line-'+cleared+'-blocked', 0, [
      {label:'SCORING BLOCKED ('+holes+' holes)', value:'0'},
    ]);
  }

  showMathOverlay(cleared,holes,piecePot,linePct,holePct,award,rowIndices);
}

// â”€â”€ EVENT TICKER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MODEL:
//   _txQueue : incoming lines waiting to appear [{text,hue}]
//   _txBuf   : visible rows [{text,hue}], oldest=0, newest=last
//
// Every DRAIN_MS, one row moves from _txQueue â†’ bottom of _txBuf.
// If _txBuf is full, oldest row shifts off the top first.
// This means multi-line pushes arrive one row at a time, staggered.
// The scroll IS the shift: oldest vanishes from top, newest appears at bottom.
// No pre-scroll, no landing zone, no disappearing from top without motion.
//
// DRAW: rows pinned to bottom of canvas. Oldest at top, newest at bottom.
// Colors travel with rows (hue stored per-row).

const TX_FONT_SIZE = 9;
const TX_LINE_H    = 13;
const TX_HUE_STEP  = 30;
const TX_HUE_DRIFT = 14;
const DRAIN_MS     = 110;  // ms between each row appearing

let _txQueue   = [];   // pending lines not yet visible
let _txBuf     = [];   // visible rows
let _txHueNext = 0;
let _txNow     = 0;
let _txMaxRows = 8;    // computed from canvas height each draw
let _txRAF     = null;
let _txDrainTO = null;

function _tickerInit(){
  _txQueue=[]; _txBuf=[]; _txHueNext=0; _txNow=0;
  clearTimeout(_txDrainTO); _txDrainTO=null;
  if(_txRAF){ cancelAnimationFrame(_txRAF); _txRAF=null; }
  const cv=document.getElementById('ticker-canvas');
  if(cv) cv.getContext('2d').clearRect(0,0,cv.width,cv.height);
}

// Push new lines into the queue â€” they drain in one at a time
function tickerPush(lines){
  for(const text of lines){
    _txQueue.push({text, hue:_txHueNext});
    _txHueNext=(_txHueNext+TX_HUE_STEP)%360;
  }
  if(!_txDrainTO) _txDrainStep();
  if(!_txRAF) _txRAF=requestAnimationFrame(_txFrame);
}

// Move one row from queue into visible buffer, schedule next
function _txDrainStep(){
  _txDrainTO=null;
  if(_txQueue.length===0) return;
  const row=_txQueue.shift();
  if(_txBuf.length>=_txMaxRows) _txBuf.shift();
  _txBuf.push(row);
  // Bridge to canvas left-panel ticker â€” throttled here, max one per DRAIN_MS
  if(typeof ui !== 'undefined'){
    ui.tickers.push({text: row.text, hue: row.hue});
    if(ui.tickers.length > _TICKER_MAX) ui.tickers.shift();
  }
  if(_txQueue.length>0){
    _txDrainTO=setTimeout(_txDrainStep, Math.max(100, DRAIN_MS));
  }
}

// rAF loop â€” color drift animation only
function _txFrame(ts){
  _txNow=ts/1000;
  _txDraw();
  if(_txBuf.length>0||_txQueue.length>0){
    _txRAF=requestAnimationFrame(_txFrame);
  } else {
    _txRAF=null;
  }
}

function _txDraw(){
  const wrap=document.getElementById('event-ticker');
  if(!wrap) return;
  const W=wrap.offsetWidth||wrap.clientWidth||80;
  const H=wrap.offsetHeight||wrap.clientHeight||120;
  if(W<4||H<4) return;

  let cv=document.getElementById('ticker-canvas');
  if(!cv){
    cv=document.createElement('canvas');
    cv.id='ticker-canvas';
    cv.style.cssText='position:absolute;top:0;left:0;width:100%;height:100%;display:block';
    wrap.appendChild(cv);
  }
  if(cv.width!==W)  cv.width=W;
  if(cv.height!==H) cv.height=H;

  _txMaxRows=Math.max(2,Math.floor(H/TX_LINE_H));

  const ctx=cv.getContext('2d');
  ctx.clearRect(0,0,W,H);
  ctx.font=`900 ${TX_FONT_SIZE}px 'Courier New',monospace`;
  ctx.textAlign='right';
  ctx.textBaseline='top';

  const n=_txBuf.length;
  // Newest row at bottom, older rows above.
  // y(i) = H - (n-i)*TX_LINE_H
  for(let i=0;i<n;i++){
    const y=H-(n-i)*TX_LINE_H;
    if(y<0||y>=H) continue;
    const hue =(_txBuf[i].hue+_txNow*TX_HUE_DRIFT)%360;
    const comp=(hue+180)%360;
    const lum =58+9*Math.sin(_txNow*0.5+i*0.42);
    const lumBright = Math.min(95, lum+28); // numbers/K get boosted lightness

    ctx.globalAlpha=1;
    ctx.shadowColor=`hsl(${comp},100%,52%)`;
    ctx.shadowBlur=6;

    // Split text into segments: numeric-with-sign/K parts get bright,
    // letter-only labels get normal lum.
    // Strategy: measure full string right-aligned, then walk segments right-to-left.
    const text=_txBuf[i].text;
    // Segment: sequences of [+\-0-9\.kğŸ”¥ğŸ§Šâ„ï¸ğŸ¥¶â˜…] are "value" segments, rest are "label"
    const segs=[];
    const re=/([+\-]?[0-9][0-9.,]*k?)|([^+\-0-9][\S]*)/gu;
    let m;
    while((m=re.exec(text))!==null){
      if(m[1]!==undefined) segs.push({t:m[1],bright:true});
      else segs.push({t:m[2],bright:false});
    }
    if(segs.length===0){ segs.push({t:text,bright:false}); }

    // Draw right-to-left, accumulating x offset
    ctx.textAlign='right';
    ctx.textBaseline='top';
    let xRight=W-2;
    for(let s=segs.length-1;s>=0;s--){
      const seg=segs[s];
      ctx.fillStyle=`hsl(${hue},100%,${seg.bright?lumBright:lum}%)`;
      ctx.fillText(seg.t, xRight, y);
      xRight-=ctx.measureText(seg.t).width;
    }
  }
  ctx.globalAlpha=1;
  ctx.shadowBlur=0;
}

function showMathOverlay(cleared, holes, pot, linePct, holePct, award, _rowIndices){
  const cs=Math.round(pot/100); // clean streak count
  const lbl=cleared>=4?`${cleared}T`:`${cleared}L`;
  if(award>0){
    tickerPush([
      fmtK(award),
      `${cs}CS ${lbl} ${holes}H`,
    ]);
  } else {
    tickerPush([`BLOCKED`,`${cs}CS ${holes}H`]);
  }
}

// â”€â”€ SCORING HOLE CHECK â€” called after every piece placement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _lastScoringHoleCheck=false;
function checkNoHoleBonus(){
  const wasHoleFree=(currentScoringHoles===0);
  if(piecesPlaced<=9 && !wasHoleFree) return;

  const newScoringHoles=countScoringHoles(board);
  const prevScoringHoles=currentScoringHoles;

  if(newScoringHoles>prevScoringHoles){
    // Scoring holes increased â€” reset piecePot and hole-free run
    if(piecePot>0||wasHoleFree) sndBonusReset();
    piecePot=0;
    _lastScoringHoleCheck=false;
    scoringDisabledSound=false;
    // Close out the hole-free run
    if(hfRun>0){
      if(hfRun>hfBest) hfBest=hfRun;
      if(hfRun>hfAllTime){
        hfAllTime=hfRun;
        tickerPush([`ğŸ¥¶ğŸ§Šâ„ï¸`,`${hfRun}CSâ˜…`]);
      } else {
        tickerPush([`ğŸ¥¶ğŸ§Šâ„ï¸`,`${hfRun}CS`]);
      }
      hfRun=0;
    }
  } else if(newScoringHoles<prevScoringHoles){
    sndBubblePop();
    // If holes just hit zero, start a new run
    if(newScoringHoles===0) hfRun=0;
  } else if(newScoringHoles===0){
    // Still hole-free â€” increment run
    hfRun++;
    // Milestone: every 10 pieces, show fire emojis (1ğŸ”¥ per 10, max 5)
    if(hfRun>0 && hfRun%10===0){
      const fires=Math.min(5,Math.floor(hfRun/10));
      tickerPush([`${'ğŸ”¥'.repeat(fires)}`,`${hfRun}CS`]);
    }
    const isNewTrigger=!_lastScoringHoleCheck;
    if(isNewTrigger){
      tickerPush([`ğŸ”¥ CS`]);
      const filled=board.reduce((s,r)=>s+r.filter(v=>v).length,0);
      const isPerfectSquare=(()=>{const sq=Math.round(Math.sqrt(filled));return sq*sq===filled&&filled>=36;})();
      const nextIsI=nxt&&nxt.k==='I';
      if(isPerfectSquare&&nextIsI){
        score+=20490;
        document.getElementById('sv').textContent=score;
        sndTetrisPerfection();
        tickerPush([`ğŸ†âœ¨ PERFECT`, `+20,490`, `ATARI TRIBUTE`]);
        txScore('super-clear',20490,[
          {label:'Perfect square + I-piece next','value':''},
          {label:'Atari SF Rush 2049 tribute','value':'+20,490'},
        ]);
      } else if(isPerfectSquare){
        sndWaitingTetris();
      } else {
        sndNoHole();
      }
    }
  }

  currentScoringHoles=newScoringHoles;
  updateHoleDisplay(newScoringHoles);
  _lastScoringHoleCheck=(newScoringHoles===0);

  const pieceBonus=Math.min(100*tetrisMultiplier,1600);
  piecePot+=pieceBonus;
  updateTBDisplay();
  checkTowers();
}

function showNHoleOverlay(){} // removed â€” ticker handles it

function showSuperOverlay(){} // removed â€” ticker handles it

// â”€â”€ TOWER DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _towerSeverity = 0;  // 0-5, last reported severity

function _colHeight(col){
  for(let r=0;r<ROWS;r++) if(board[r*COLS+col]) return ROWS-r;
  return 0;
}

// Smoke alarm chirp â€” real T3 alarm fundamental ~3150 Hz
// count = 1-5 alarms, each slightly detuned, random gap 100-200ms between chirps
function sndSmokeAlarm(count){
  const ac=getAC(); if(ac.state==='suspended')ac.resume();
  const BASE=3150;
  const detune=[0,+18,-23,+37,-41]; // each alarm slightly off â€” like dying batteries
  let t=ac.currentTime;
  for(let i=0;i<Math.min(count,5);i++){
    if(i>0) t+=(0.10+Math.random()*0.10); // 100-200ms random gap
    const freq=BASE+detune[i];
    const g=ac.createGain();
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.28,t+0.004); // sharp attack
    g.gain.setValueAtTime(0.28,t+0.055);           // hold
    g.gain.exponentialRampToValueAtTime(0.0001,t+0.090); // fast decay
    const o=ac.createOscillator();
    o.type='square';
    o.frequency.setValueAtTime(freq,t);
    // tiny mid-chirp wobble â€” cheap/battery-dying feel
    o.frequency.setValueAtTime(freq*(1+0.004*(Math.random()-0.5)),t+0.025);
    o.connect(g);g.connect(getMaster());
    o.start(t);o.stop(t+0.095);
  }
}

function checkTowers(){
  const h=[];
  for(let c=0;c<COLS;c++) h.push(_colHeight(c));

  const mean=h.reduce((a,b)=>a+b,0)/COLS;

  // Count locally-prominent columns that exceed mean by >=3 rows
  let rawCount=0;
  for(let c=0;c<COLS;c++){
    if(h[c]-mean>=3){
      const lh=c>0?h[c-1]:0;
      const rh=c<COLS-1?h[c+1]:0;
      if(h[c]>lh||h[c]>rh) rawCount++;
    }
  }

  // severity = floor(rawCount/3), capped 0-5
  // 3 prominent cols â†’ sev 1, 6 â†’ sev 2, 9 â†’ sev 3, etc.
  const sev=Math.min(5,Math.floor(rawCount/3));

  if(sev===_towerSeverity) return;
  const prev=_towerSeverity;
  _towerSeverity=sev;

  if(sev===0){
    if(prev>=1) tickerPush([`â›°ï¸â¡ï¸âœ…`,`TOWERS CLEARED`]);
    return;
  }
  if(sev<=prev) return; // de-escalating â€” silence

  sndSmokeAlarm(sev);

  const emoji='ğŸ—¼'.repeat(sev);
  const msgs=['','GETTING TALL','HIGHTOWER ALERT','BUILDING TOWERS!','DAD DISAPPROVES','HIGHTOWER LIVES'];
  tickerPush([emoji,msgs[sev]]);
}

// board,score,level,lines,hi,dead,paused declared at top
// Hole-free run tracking
// hfRun   : pieces placed since last scoring-hole creation (current game)
// hfBest  : longest hfRun achieved in current game
// hfAllTime: longest run ever across all games (persists like hi)
let hfRun=0, hfBest=0, hfAllTime=0, _gamesPlayed=0;
// cur,cx,cy,nxt declared at top
var dropIv,selIv,timerMax,timerLeft; // placements declared at top
let allCands=[],shownFootprints=new Set();
// playerHasMoved declared at top
// moveStartTime declared at top
let labelPositions=[];
// AT declared at top

// â”€â”€ No-hole bonus tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// piecePot declared at top
// tetrisPot declared at top
let piecesPlaced=0;        // total pieces placed this game
let tetrisStreak=0;        // consecutive Tetris clears
let tetrisMultiplier=1;    // doubles each consecutive Tetris, cap at 16
let currentScoringHoles=0; // live countScoringHoles on the board, updated each placement
let scoringDisabledSound=false;
// noHoleActive derived: currentScoringHoles===0
// holeBaseline removed: was countScoringHoles-based, no longer meaningful

// â”€â”€ Particle / explosion system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// particles declared at top
// explodedCells declared at top
let clearAnimating=false;  // true while line-clear explosion runs

CELL=20; // initialized above

// AUTO_PLAY declared at top
// AUTO_SPEED declared at top
// autoUsed declared at top
let puzzleTargets = []; // [{k,rot,x,dropY}] correct placement for each puzzle piece

let puzzleQueue = [];
let puzzleActive = false;
let puzzleWellCol = 9;


// â”€â”€ Puzzle system constants (extracted from game logic gap) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PUZZLE_GRIDS = [
  ['ABCCCDDDD','ABBCEEEFF','AGBHHEIIF','AGGGHHIIF'],
  ['ABCCDDDEE','ABBCCDFFE','AGBHHHFFE','AGGGHIIII'],
  ['ABBCCCDDD','AEBBCFFGD','AEHHHFFGG','AEEHIIIIG'],
  ['ABCDDDEEE','ABCCDFFFE','ABBCGGFHH','AIIIIGGHH'],
  ['AABCCCDDD','AABBCEEED','FFFBGGEHH','FIIIIGGHH'],
  ['AAABBBCCC','DAEEBFFGC','DHHEEFFGG','DDHHIIIIG'],
  ['ABBBCCCCD','AABEEEFFD','GAHHEIIFD','GGGHHIIFD'],
  ['ABBBCCCDD','AABEECFFD','GAHHEEFFD','GGGHHIIII'],
  ['ABBCCCDDE','AABBCFFDE','GAHHHFFDE','GGGHIIIIE'],
  ['AABBBCCCD','EAABFFGCD','EHHHFFGGD','EEHIIIIGD'],
  ['ABCCCDDDD','ABBCEEEFF','AABGGEHFF','IIIIGGHHH'],
  ['ABCCCDDDE','ABBCFFFDE','AABGGFHHE','IIIIGGHHE'],
  ['ABCCDDDEE','ABBCCDFEE','AABGGGFFF','HHHHGIIII'],
];
const PUZZLE_PIECE_TYPES = [
  {A:'I',B:'S',C:'T',D:'I',E:'T',F:'L',G:'J',H:'Z',I:'O'},
  {A:'I',B:'S',C:'Z',D:'T',E:'L',F:'O',G:'J',H:'T',I:'I'},
  {A:'I',B:'Z',C:'T',D:'J',E:'L',F:'O',G:'S',H:'T',I:'I'},
  {A:'I',B:'L',C:'S',D:'T',E:'J',F:'T',G:'Z',H:'O',I:'I'},
  {A:'O',B:'S',C:'T',D:'J',E:'T',F:'L',G:'Z',H:'O',I:'I'},
  {A:'T',B:'T',C:'J',D:'L',E:'Z',F:'O',G:'S',H:'Z',I:'I'},
  {A:'S',B:'T',C:'I',D:'I',E:'T',F:'L',G:'J',H:'Z',I:'O'},
  {A:'S',B:'T',C:'T',D:'L',E:'Z',F:'O',G:'J',H:'Z',I:'I'},
  {A:'S',B:'Z',C:'T',D:'L',E:'I',F:'O',G:'J',H:'T',I:'I'},
  {A:'Z',B:'T',C:'J',D:'I',E:'L',F:'O',G:'S',H:'T',I:'I'},
  {A:'L',B:'S',C:'T',D:'I',E:'T',F:'O',G:'Z',H:'J',I:'I'},
  {A:'L',B:'S',C:'T',D:'J',E:'I',F:'T',G:'Z',H:'O',I:'I'},
  {A:'L',B:'S',C:'Z',D:'T',E:'O',F:'J',G:'T',H:'I',I:'I'},
];
const BOARD_PUZZLE_TOP = ROWS - 4;
const PROOF_MODE = false;
const PROWS=4, PCOLS=9;

function buildPuzzleQueue(){
  const si = Math.random()*PUZZLE_GRIDS.length|0;
  const mirror = Math.random()<0.5;
  const rawGrid = PUZZLE_GRIDS[si];
  // When mirroring, Sâ†”Z and Jâ†”L (chirality flips)
  const mirrorType = {I:'I',O:'O',T:'T',S:'Z',Z:'S',J:'L',L:'J'};
  const baseTypeMap = PUZZLE_PIECE_TYPES[si];
  const typeMap = mirror
    ? Object.fromEntries(Object.entries(baseTypeMap).map(([k,v])=>[k,mirrorType[v]]))
    : baseTypeMap;
  puzzleWellCol = mirror ? 0 : 9;
  const BOARD_PUZZLE_TOP = 21; // board has 25 rows, puzzle fills bottom 4 = rows 21-24

  const grid = rawGrid.map(row => mirror ? row.split('').reverse().join('') : row);
  const g = grid.map(row=>row.split(''));
  const PROWS=4, PCOLS=9;
  // If well is on left, puzzle occupies cols 1-9; if right, cols 0-8
  const colOffset = mirror ? 1 : 0;

  function getPieceCells(gg){
    const pc={};
    for(let r=0;r<PROWS;r++) for(let c=0;c<PCOLS;c++){
      const ch=gg[r][c];
      if(ch!=='.'){if(!pc[ch])pc[ch]=[];pc[ch].push([r,c]);}
    }
    return pc;
  }

  function pullable(gg){
    const pc=getPieceCells(gg);
    // Pull from BOTTOM: piece is free if nothing below it belongs to another piece
    // This gives bottom-up deal order so gravity stacks correctly
    return Object.keys(pc).filter(lbl=>{
      for(const[r,c] of pc[lbl])
        if(r<PROWS-1 && gg[r+1][c]!=='.' && gg[r+1][c]!==lbl) return false;
      return true;
    });
  }

  // Find which NRS rotation matches a set of cells
  function findRotX(k, cells){
    const minr=Math.min(...cells.map(([r])=>r));
    const minc=Math.min(...cells.map(([,c])=>c));
    const norm=cells.map(([r,c])=>`${r-minr},${c-minc}`).sort().join('|');
    for(let ri=0;ri<NRS[k].length;ri++){
      const rot=NRS[k][ri];
      const rn=[];
      for(let r=0;r<rot.length;r++) for(let c=0;c<rot[r].length;c++)
        if(rot[r][c]) rn.push(`${r},${c}`);
      if(rn.sort().join('|')===norm) return{rot:ri, x:minc+colOffset};
    }
    return{rot:0, x:minc+colOffset};
  }

  const seq=[], targets=[];
  while(true){
    const avail=pullable(g);
    if(!avail.length) break;
    const chosen=avail[Math.random()*avail.length|0];
    const cells=getPieceCells(g)[chosen];
    const k=typeMap[chosen];
    const{rot,x}=findRotX(k,cells);
    const minr=Math.min(...cells.map(([r])=>r));
    const dropY=minr+BOARD_PUZZLE_TOP;
    seq.push({k, rgb:[...PTYPES[k].rgb]});
    targets.push({k, rot, x, dropY});
    for(let r=0;r<PROWS;r++) for(let c=0;c<PCOLS;c++)
      if(g[r][c]===chosen) g[r][c]='.';
  }

  if(seq.length!==9){ puzzleActive=false; return; }

  // 10th piece: I-piece only if the well column will be completely empty after
  // the 9 puzzle pieces are placed. The puzzle fills exactly 9 cols so the well
  // col (0 or 9) is always untouched â€” but verify col is in bounds just in case.
  // Also: if by some freak the player placed a previous piece in the well col
  // (only possible if they ignored the hint), fall back to random.
  const tetrisPossible = (puzzleWellCol >= 0 && puzzleWellCol < COLS);

  if(tetrisPossible){
    seq.push({k:'I', rgb:[...PTYPES.I.rgb]});
    // Target will be resolved at deal time against live board (see mkPiece)
    targets.push({k:'I', rot:1, x:puzzleWellCol, dropY:BOARD_PUZZLE_TOP});
  } else {
    const rk=PK.filter(k=>k!=='I')[Math.random()*6|0];
    seq.push({k:rk, rgb:[...PTYPES[rk].rgb]});
    targets.push(null); // no hint â€” normal AI takes over
  }

  puzzleQueue = seq;
  puzzleTargets = targets;
  puzzleActive = true;
}

function mkPiece(){
  if(puzzleActive && puzzleQueue.length>0){
    const p=puzzleQueue.shift();
    if(puzzleQueue.length===0) puzzleActive=false;
    return{k:p.k,rot:0,c:NRS[p.k][0].map(r=>[...r]),rgb:p.rgb};
  }
  const k=PK[Math.random()*PK.length|0];
  return{k,rot:0,c:NRS[k][0].map(r=>[...r]),rgb:[...PTYPES[k].rgb]};
}

// Called in spawn() after cur is set â€” if cur is the puzzle I-piece,
// verify the board (with all 9 pieces now placed) still allows a Tetris.
// If not, silently swap cur to a random non-I piece.
function verifyTetrisPiece(){
  // Called right after nxt is fetched â€” if nxt is the puzzle I-piece,
  // check NOW (8 pieces on board) whether a Tetris will be possible.
  // We check one piece early so the preview box never shows the wrong piece.
  if(!nxt || nxt.k!=='I') return;
  if(!puzzleTargets.length) return;
  // Only apply to the last target (the Tetris well piece, targets.length===1)
  if(puzzleTargets.length!==1) return;
  const PUZZLE_TOP = ROWS - 4;
  // Check rows above puzzle zone are clear
  const nothingAbove = board.slice(0, PUZZLE_TOP).every(row => row.every(v => !v));
  // Check at least one full-column well exists in puzzle rows
  const hasWell = Array.from({length:COLS},(_,c)=>c)
    .some(c => board.slice(PUZZLE_TOP).every(row => !row[c]));
  if(!nothingAbove || !hasWell){
    const dbg=document.getElementById('proof-debug');
    if(dbg&&PROOF_MODE) dbg.textContent+=`\nâš  Tetris blocked â€” swapping I to random`;
    const rk = PK.filter(k=>k!=='I')[Math.random()*6|0];
    nxt = {k:rk, rot:0, c:NRS[rk][0].map(r=>[...r]), rgb:[...PTYPES[rk].rgb]};
    if(puzzleTargets.length>0) puzzleTargets[0]=null;
  }
}

// NRS rotation: look up the next state from the pre-defined table.
// Direction: 1=CW, -1=CCW
function rotNRS(piece,d=1){
  const states=NRS[piece.k];
  const next=((piece.rot+(d===1?1:3))%4);
  return{...piece,rot:next,c:states[next].map(r=>[...r])};
}

// Legacy rotMat kept for BFS/evalP internals that build rotation arrays
function rotMat(m,d=1){
  const R=m.length,C=m[0].length;
  if(d===1){const o=Array.from({length:C},()=>Array(R).fill(0));for(let r=0;r<R;r++)for(let c=0;c<C;c++)o[c][R-1-r]=m[r][c];return o}
  else{const o=Array.from({length:C},()=>Array(R).fill(0));for(let r=0;r<R;r++)for(let c=0;c<C;c++)o[C-1-c][r]=m[r][c];return o}
}

function isOk(c,bx,by,b=board){
  for(let r=0;r<c.length;r++)for(let cc=0;cc<c[r].length;cc++){
    if(!c[r][cc])continue;
    const nx=bx+cc,ny=by+r;
    if(nx<0||nx>=COLS||ny>=ROWS)return false;
    if(ny>=0&&b[ny][nx])return false;
  }return true;
}

function ghostY(){let g=cy;while(isOk(cur.c,cx,g+1))g++;return g}

function spawn(){
  cur=nxt||mkPiece();nxt=mkPiece();

  // Spawn-time scoring-hole check: did the previous clear create scoring holes
  // via collapse? If so alert the player now rather than waiting for next placement.
  const spawnScoringHoles=countScoringHoles(board);
  if(spawnScoringHoles>currentScoringHoles){
    sndBonusReset();
    piecePot=0;
    _lastScoringHoleCheck=false;
  } else if(spawnScoringHoles<currentScoringHoles){
    sndBubblePop();
  }
  currentScoringHoles=spawnScoringHoles;
  updateHoleDisplay(spawnScoringHoles);

  // Check if the upcoming I-piece (now in nxt preview) is still valid.
  // Run while 8 pieces are on the board so the preview never shows wrong piece.
  verifyTetrisPiece();

  const pw=cur.c[0].length;
  cx = pw===4 ? 3 : pw===2 ? 4 : 3;
  cy=0;

  if(!isOk(cur.c,cx,cy)){triggerDead();return;}

  sndSpawn();
  stopDrop();
  calcPlacements(true);startSelTimer();drawNext();
}

// Scan all rotations Ã— all x positions at rows 0-1.
// Score each valid position by how wide the clear run is above it
// (prefers the center of the widest open corridor at the top).
// Returns {cells, x} of the best fit, or null if truly no space.
function _findOpenSpawn(piece){
  const k=piece.k||Object.keys(PTYPES).find(k=>
    PTYPES[k].rgb[0]===piece.rgb[0]&&PTYPES[k].rgb[1]===piece.rgb[1]&&PTYPES[k].rgb[2]===piece.rgb[2]
  )||'I';

  const topClear=Array(COLS).fill(0);
  for(let c=0;c<COLS;c++){
    if(!board[0][c]&&!board[1][c])topClear[c]=1;
  }

  let best=null,bestScore=-Infinity;

  for(let i=0;i<4;i++){
    const cells=NRS[k][i];
    const pw=cells[0].length;
    for(let x=0;x<=COLS-pw;x++){
      if(!isOk(cells,x,0))continue;
      let clearCount=0;
      for(let c=x;c<x+pw;c++)clearCount+=topClear[c]||0;
      const centerDist=Math.abs((x+pw/2)-(COLS/2));
      const score=clearCount*10 - centerDist;
      if(score>bestScore){
        bestScore=score;
        best={cells:cells.map(r=>[...r]),x,rot:i};
      }
    }
  }
  return best;
}

function placeOn(b,c,x,y,rgb){
  for(let r=0;r<c.length;r++)for(let cc=0;cc<c[r].length;cc++)
    if(c[r][cc]&&y+r>=0&&y+r<ROWS&&x+cc>=0&&x+cc<COLS)b[y+r][x+cc]=rgb;
}

// Score a board state purely on its static properties (no piece placement)
function scoreBoard(b){
  let totalH=0,holes=0,bump=0;
  const colH=[];
  for(let c=0;c<COLS;c++){
    let h=0,block=false,colHoles=0;
    for(let r=0;r<ROWS;r++){
      if(b[r][c]){h=Math.max(h,ROWS-r);block=true;}
      else if(block)colHoles++;
    }
    colH.push(h);totalH+=h;holes+=colHoles;
  }
  for(let c=0;c<COLS-1;c++)bump+=Math.abs(colH[c]-colH[c+1]);

  const maxH=Math.max(...colH);
  const minH=Math.min(...colH);

  // Danger ramp: 0 at maxHâ‰¤12, quadratic to 1.0 at maxH=22
  const DANGER_START=12, DANGER_FULL=22;
  const danger=Math.max(0,Math.min(1,(maxH-DANGER_START)/(DANGER_FULL-DANGER_START)));
  const dangerSq=danger*danger;

  const heightPenalty=totalH*5*(1+dangerSq*5);
  const maxHPenalty=maxH*maxH*dangerSq*2;

  // â”€â”€ Canyon penalty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Any column that is 3+ rows shallower than both its neighbors is a canyon.
  // Canyons are unreachable traps â€” penalise hard regardless of hole count.
  // Depth beyond threshold compounds quadratically.
  let canyonPenalty=0;
  for(let c=1;c<COLS-1;c++){
    const leftDiff =colH[c-1]-colH[c];
    const rightDiff=colH[c+1]-colH[c];
    // Both neighbours are taller â€” it's a valley/canyon
    if(leftDiff>0&&rightDiff>0){
      const depth=Math.min(leftDiff,rightDiff); // how deep relative to shorter neighbour
      if(depth>=2) canyonPenalty+=depth*depth*30;
    }
  }

  // â”€â”€ Height variance penalty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // High variance means uneven skyline â€” hard to fill cleanly.
  // Penalise (max-min) spread, scaled by how tall the board is.
  const spread=maxH-minH;
  const spreadPenalty=spread>6 ? (spread-6)*(spread-6)*8*(1+dangerSq*3) : 0;

  // â”€â”€ Isolated tall column penalty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // A column that is 4+ taller than the average of its two neighbours
  // is a spike â€” it will force bad placements on future pieces.
  let spikePenalty=0;
  for(let c=0;c<COLS;c++){
    const leftH =c>0     ?colH[c-1]:colH[c];
    const rightH=c<COLS-1?colH[c+1]:colH[c];
    const neighbourAvg=(leftH+rightH)/2;
    const spike=colH[c]-neighbourAvg;
    if(spike>=4) spikePenalty+=spike*spike*12;
  }

  return -heightPenalty - holes*40 - bump*8 - maxHPenalty
         - canyonPenalty - spreadPenalty - spikePenalty;
}

// Clear lines on a test board, return [clearedCount, newBoard]
function simClear(b){
  let nb=b.filter(r=>!r.every(v=>v));
  const cl=ROWS-nb.length;
  while(nb.length<ROWS)nb.unshift(Array(COLS).fill(null));
  return[cl,nb];
}

// Best score achievable for `piece` on board `b`, starting from row 0
function bestNextScore(piece,b){
  let best=-Infinity;
  const k=piece.k||Object.keys(PTYPES).find(k=>
    PTYPES[k].rgb[0]===piece.rgb[0]&&PTYPES[k].rgb[1]===piece.rgb[1]&&PTYPES[k].rgb[2]===piece.rgb[2]
  )||'I';
  const rots=NRS[k].map(r=>r.map(row=>[...row]));

  // Activate hole-aware lookahead only when buried cells exist.
  // Clean board = Tetris-prep strategy dominates, no interference.
  const buriedOnB=countBuriedCells(b);
  const holeMode=buriedOnB>0;

  const evalPos=(cc,x,gy)=>{
    const tb2=b.map(r=>[...r]);
    placeOn(tb2,cc,x,gy,piece.rgb);
    const[cl2,nb2]=simClear(tb2);
    let sc=cl2*800+scoreBoard(nb2);
    if(holeMode){
      const bBefore=buriedOnB;
      const bAfter=countBuriedCells(nb2);
      const bDelta=bAfter-bBefore;
      sc+=bDelta<0
        ?(-bDelta)*HOLE_REDUCE_BONUS
        :bDelta>0?(-bDelta)*HOLE_CREATE_PENALTY:0;
      sc-=bAfter*HOLE_EXIST_PENALTY;
    }
    return sc;
  };

  // Always evaluate straight drops
  for(let rot=0;rot<4;rot++){
    const cc=rots[rot];
    for(let x=0;x<=COLS-cc[0].length;x++){
      if(!isOk(cc,x,0,b))continue;
      let gy=0;while(isOk(cc,x,gy+1,b))gy++;
      const sc=evalPos(cc,x,gy);
      if(sc>best)best=sc;
    }
  }

  // BFS slide lookahead â€” only when holes exist and need filling
  if(holeMode){
    try{
      const slides=bfsAllReachable(k,rots,b);
      for(const{x,rot,dropY}of slides){
        if(!rots[rot]||!rots[rot][0])continue;
        const sc=evalPos(rots[rot],x,dropY)+slideBonus(1);
        if(sc>best)best=sc;
      }
    }catch(e){/* lookahead is best-effort */}
  }

  return best===-Infinity?scoreBoard(b):best;
}

function evalP(cells,x,y){
  if(!cur)return -Infinity;
  const tb=board.map(r=>[...r]);
  placeOn(tb,cells,x,y,cur.rgb);
  const[cl,nb]=simClear(tb);

  const curScore=cl*800+scoreBoard(nb);
  const nextScore=nxt?bestNextScore(nxt,nb):0;

  // AI evaluation uses countBuriedCells â€” the landscape messiness metric.
  // This correctly penalises reachable overhangs too, since they still
  // constrain future placement options even if a piece can slide in.
  const buriedBefore=countBuriedCells(board);
  const buriedAfter =countBuriedCells(nb);
  const buriedDelta =buriedAfter-buriedBefore;

  const buriedScore = buriedDelta<0
    ? (-buriedDelta)*HOLE_REDUCE_BONUS    // uncovering cells: reward
    : buriedDelta>0
      ? (-buriedDelta)*HOLE_CREATE_PENALTY  // burying new cells: penalty
      : 0;

  // Continuous pressure per buried cell â€” always incentivises cleanup
  const buriedExistScore=-buriedAfter*HOLE_EXIST_PENALTY;

  // Permanent holes: cells no piece can ever cover â€” catastrophic penalty
  // Only compute when buried cells exist (expensive BFS, skip when clean)
  let permanentScore=0;
  if(buriedAfter>0){
    const permBefore=countPermanentHoles(board);
    const permAfter =countPermanentHoles(nb);
    const permDelta =permAfter-permBefore;
    if(permDelta>0) permanentScore=-permDelta*PERMANENT_HOLE_PENALTY;
    else if(permDelta<0) permanentScore=(-permDelta)*HOLE_REDUCE_BONUS*1.5;
  }

  // Gap-fill bonus (slide-accessible cavity match)
  const gapBonus=gapFillBonus(cells,x,y);

  // Tetris-prep bonus/penalty (fades with danger)
  const prepScore=tetrisPrepScore(cells,x);

  return curScore + nextScore*0.4 + buriedScore + buriedExistScore
       + permanentScore + gapBonus + prepScore;
}

// â”€â”€â”€ TETRIS-PREP STRATEGY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TETRIS_PREP_BONUS  = 12000;
const TETRIS_PREP_PENALTY= 25000;
const HOLE_REDUCE_BONUS  = 40000;  // per buried cell eliminated
const HOLE_CREATE_PENALTY= 60000;  // per new buried cell created
const HOLE_EXIST_PENALTY =  8000;  // per buried cell still on board
const PERMANENT_HOLE_PENALTY=120000; // per cell no piece can ever reach â€” near-fatal
const SLIDE_BONUS        =  8000;
const SLIDE_HOLE_PENALTY = 60000;

// Slide bonus scales with lateral distance: deeper slides earn more
function slideBonus(dist){
  if(dist<=1)return SLIDE_BONUS;
  if(dist===2)return SLIDE_BONUS*1.6;
  return SLIDE_BONUS*2;
}

let tetrisPrepCol   = -1;
let tetrisPrepActive= false;

// Count buried empty cells on board b.
// A hole is any empty cell (row r, col c) where some filled cell exists at row < r in col c.
// â”€â”€ THREE DISTINCT HOLE CONCEPTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// countBuriedCells(b)   â€” column scan: any empty cell with a filled cell above
//                         it in the same column. Fast. Used by AI evaluation
//                         (scoreBoard, evalP) as a landscape messiness metric.
//                         Does NOT distinguish reachable from permanently trapped.
//
// countScoringHoles(b)  â€” flood-fill from top: empty cells with no connected
//                         path to open sky. Drives piecePot reset, fractional
//                         awards, and the Holes display. An overhang you CAN
//                         slide into is NOT a scoring hole.
//
// countPermanentHoles(b)â€” BFS piece reachability: buried cells that CANNOT be
//                         covered by any piece in any rotation via any legal
//                         move sequence. Truly unrecoverable. Used as a heavy
//                         penalty in evalP.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function countBuriedCells(b){
  let h=0;
  for(let c=0;c<COLS;c++){
    let blocked=false;
    for(let r=0;r<ROWS;r++){
      if(b[r][c])blocked=true;
      else if(blocked)h++;
    }
  }
  return h;
}

// countScoringHoles: flood-fill from open sky. Drives display + award economics.
// A cell reachable via any lateral path is NOT a scoring hole.
function countScoringHoles(b){
  const visited=new Uint8Array(ROWS*COLS);
  const idx=(r,c)=>r*COLS+c;
  const queue=[];

  // Seed from every empty cell in row 0
  for(let c=0;c<COLS;c++){
    if(!b[0][c]){visited[idx(0,c)]=1;queue.push([0,c]);}
  }

  // Flood fill through all connected empty cells
  let qi=0;
  while(qi<queue.length){
    const[r,c]=queue[qi++];
    const nb=[[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
    for(const[nr,nc] of nb){
      if(nr<0||nr>=ROWS||nc<0||nc>=COLS)continue;
      if(b[nr][nc])continue; // filled cell â€” wall
      const k=idx(nr,nc);
      if(!visited[k]){visited[k]=1;queue.push([nr,nc]);}
    }
  }

  // Any empty cell that wasn't reached is a true hole
  let h=0;
  for(let r=0;r<ROWS;r++)
    for(let c=0;c<COLS;c++)
      if(!b[r][c]&&!visited[idx(r,c)])h++;
  return h;
}

// True only when the LIVE board has zero holes (original simple definition).
// countPermanentHoles: BFS piece reachability check.
// For each buried empty cell, tests whether ANY piece type in ANY rotation
// can physically reach a landing position that covers that cell.
// Cells that fail this test are permanently unrecoverable â€” no future piece
// can ever fill them. Used as a heavy penalty in evalP only (expensive).
function countPermanentHoles(b){
  // First collect all buried empty cells (column-scan style)
  const buried=[];
  for(let c=0;c<COLS;c++){
    let blocked=false;
    for(let r=0;r<ROWS;r++){
      if(b[r][c])blocked=true;
      else if(blocked)buried.push([r,c]);
    }
  }
  if(!buried.length)return 0;

  // For each piece type + rotation, precompute all cells it covers at each
  // possible landing position, and mark those cells as coverable.
  const coverable=new Set();
  for(const k of PK){
    for(let rot=0;rot<4;rot++){
      const cc=NRS[k][rot];
      if(!cc||!cc[0])continue;
      const ph=cc.length, pw=cc[0].length;
      for(let x=0;x<=COLS-pw;x++){
        // Find all reachable landing positions for this piece on board b
        // Use straight drops plus BFS slides
        const landings=[];
        if(isOk(cc,x,0,b)){
          let gy=0; while(isOk(cc,x,gy+1,b))gy++;
          landings.push(gy);
        }
        // Also check one row above all filled positions for slides
        // (lightweight approximation â€” full BFS per buried cell is too slow)
        for(const gy of landings){
          for(let r=0;r<ph;r++)
            for(let c2=0;c2<pw;c2++)
              if(cc[r][c2])coverable.add(`${gy+r},${x+c2}`);
        }
      }
    }
  }

  // A buried cell is permanent if nothing can ever cover it
  let permanent=0;
  for(const[r,c] of buried){
    if(!coverable.has(`${r},${c}`))permanent++;
  }
  return permanent;
}

// boardIsHoleFree: uses countBuriedCells â€” the AI strategy metric.
// This is intentionally NOT countScoringHoles â€” we want Tetris-prep
// to activate only when the board has no covered cells at all.
function boardIsHoleFree(){return countBuriedCells(board)===0;}

function updateTetrisPrepStrategy(){
  // Must be completely hole-free
  if(!boardIsHoleFree()){tetrisPrepActive=false;tetrisPrepCol=-1;return;}

  // Pick emptier edge column as the Tetris well
  const leftH =_colTopRow(0);
  const rightH=_colTopRow(9);
  const reserveCol=leftH>=rightH?0:9;

  // Every piece type must be placeable entirely within the 9 non-reserved columns
  const testCols=Array.from({length:9},(_,i)=>reserveCol===0?i+1:i);
  for(const k of PK){
    if(!_pieceCanLandIn(k,testCols)){
      tetrisPrepActive=false;tetrisPrepCol=-1;
      return;
    }
  }

  tetrisPrepActive=true;
  tetrisPrepCol=reserveCol;
}

function _colTopRow(c){
  for(let r=0;r<ROWS;r++)if(board[r][c])return r;
  return ROWS;
}

function _pieceCanLandIn(k,allowedCols){
  const allowSet=new Set(allowedCols);
  for(let rot=0;rot<4;rot++){
    const cc=NRS[k][rot];
    for(let x=0;x<COLS;x++){
      if(!isOk(cc,x,0))continue;
      let ok=true;
      for(let r=0;r<cc.length&&ok;r++)
        for(let c=0;c<cc[r].length&&ok;c++)
          if(cc[r][c]&&!allowSet.has(x+c))ok=false;
      if(ok)return true;
    }
  }
  return false;
}

function tetrisPrepScore(cells,px){
  if(!tetrisPrepActive)return 0;

  // Measure current board danger â€” same scale as scoreBoard
  const DANGER_START=10, DANGER_FULL=20;
  let maxH=0;
  for(let c=0;c<COLS;c++){
    for(let r=0;r<ROWS;r++){
      if(board[r][c]){maxH=Math.max(maxH,ROWS-r);break;}
    }
  }
  const danger=Math.max(0,Math.min(1,(maxH-DANGER_START)/(DANGER_FULL-DANGER_START)));
  // Tetris-prep fades linearly: full bonus below danger 0.3, zero above danger 0.7
  const prepWeight=Math.max(0,Math.min(1,(0.7-danger)/0.4));
  if(prepWeight<=0)return 0;

  let invades=false;
  outer:for(let r=0;r<cells.length;r++)for(let c=0;c<cells[r].length;c++){
    if(cells[r][c]&&px+c===tetrisPrepCol){invades=true;break outer;}
  }
  const raw=invades?-TETRIS_PREP_PENALTY:TETRIS_PREP_BONUS;
  return raw*prepWeight;
}

// A "gap" is a cavity that can only be filled by sliding a piece in laterally â€”
// not by dropping straight down from the top. Each gap has a specific piece
// type and rotation that fits it. We keep a live wishlist rebuilt after each
// lock, and give a large bonus when the current piece can reach a gap.

// All piece shapes in all rotations, keyed by type.
// Use NRS tables directly â€” no rotMat needed here.
const GAP_PIECES=(()=>{
  const shapes={};
  for(const k of PK){
    const seen=new Set();
    shapes[k]=[];
    for(let i=0;i<4;i++){
      const key=NRS[k][i].map(r=>r.join('')).join('|');
      if(!seen.has(key)){seen.add(key);shapes[k].push({rot:i,c:NRS[k][i].map(r=>[...r])});}
    }
  }
  return shapes;
})();

// BFS reachability: can `cells` (a piece shape) reach position (targetX, targetY)
// on board `b`, starting from row 0 at every column?
// State: (x, y, rotation_index). We treat all 4 rotations as reachable via
// rotate-in-place moves (only where the board allows it).
// Returns true if the piece can reach the target state via valid moves.
function canReach(pieceKey,targetRot,targetX,targetY,b){
  const rots=NRS[pieceKey].map(r=>r.map(row=>[...row]));

  const VSIZE=COLS*ROWS*4;
  const encode=(x,y,rot)=>(x*ROWS+y)*4+rot;
  const visited=new Uint8Array(VSIZE);

  const queue=[];
  for(let rot=0;rot<4;rot++){
    const cells=rots[rot];
    if(!cells||!cells[0]||!cells[0].length)continue;
    const pw=cells[0].length;
    for(let x=0;x<=COLS-pw;x++){
      if(isOk(cells,x,0,b)){
        const key=encode(x,0,rot);
        if(key>=0&&key<VSIZE&&!visited[key]){visited[key]=1;queue.push([x,0,rot]);}
      }
    }
  }

  let qi=0;
  while(qi<queue.length){
    const[x,y,rot]=queue[qi++];
    if(rot===targetRot&&x===targetX&&y===targetY)return true;

    const cells=rots[rot];
    if(!cells||!cells[0]||!cells[0].length)continue;
    const pw=cells[0].length;

    // Move down
    if(y+1<ROWS&&isOk(cells,x,y+1,b)){
      const key=encode(x,y+1,rot);
      if(key>=0&&key<VSIZE&&!visited[key]){visited[key]=1;queue.push([x,y+1,rot]);}
    }
    // Move left
    if(x>0&&isOk(cells,x-1,y,b)){
      const key=encode(x-1,y,rot);
      if(key>=0&&key<VSIZE&&!visited[key]){visited[key]=1;queue.push([x-1,y,rot]);}
    }
    // Move right
    if(x+pw<COLS&&isOk(cells,x+1,y,b)){
      const key=encode(x+1,y,rot);
      if(key>=0&&key<VSIZE&&!visited[key]){visited[key]=1;queue.push([x+1,y,rot]);}
    }
    // Rotate CW
    const rotCW=(rot+1)%4;
    const cCW=rots[rotCW];
    if(cCW&&cCW[0]&&cCW[0].length&&x+cCW[0].length<=COLS&&isOk(cCW,x,y,b)){
      const key=encode(x,y,rotCW);
      if(key>=0&&key<VSIZE&&!visited[key]){visited[key]=1;queue.push([x,y,rotCW]);}
    }
    // Rotate CCW
    const rotCCW=(rot+3)%4;
    const cCCW=rots[rotCCW];
    if(cCCW&&cCCW[0]&&cCCW[0].length&&x+cCCW[0].length<=COLS&&isOk(cCCW,x,y,b)){
      const key=encode(x,y,rotCCW);
      if(key>=0&&key<VSIZE&&!visited[key]){visited[key]=1;queue.push([x,y,rotCCW]);}
    }
  }
  return false;
}

// Scan the board for all slide-only-fillable gaps and which piece fits each.
// A placement (pieceKey, rot, x, dropY) is a gap if:
//   1. The piece fits at (x, dropY) â€” it's a legal resting position
//   2. The piece CANNOT reach (x, dropY) by dropping straight from row 0
//      (i.e., the direct-drop landing y is LESS than dropY â€” something blocks above)
//   3. A BFS from all entry points CAN still reach (x, dropY) via lateral moves
// This exactly captures "must slide in horizontally to reach the cavity."
let gapList=[];

function rebuildGapList(){
  gapList=[];
  if(!board)return;

  for(const k of PK){
    for(const{rot,c}of GAP_PIECES[k]){
      const ph=c.length, pw=c[0].length;
      for(let x=0;x<=COLS-pw;x++){
        // Where does a straight drop land?
        if(!isOk(c,x,0))continue; // blocked at very top â€” can't enter
        let directY=0;
        while(isOk(c,x,directY+1))directY++;

        // Now check every position BELOW the direct landing
        // (directY+1 onward) â€” these can only be reached by lateral navigation
        for(let ty=directY+1;ty<=ROWS-ph;ty++){
          if(!isOk(c,x,ty))break; // piece doesn't fit here, deeper won't either

          // Piece fits here but can't be reached by straight drop.
          // Check full BFS reachability.
          if(canReach(k,rot,x,ty,board)){
            // Avoid duplicates
            if(!gapList.some(g=>g.pieceKey===k&&g.rot===rot&&g.x===x&&g.dropY===ty))
              gapList.push({pieceKey:k,rot,x,dropY:ty,reachable:true});
          }
        }
      }
    }
  }
}

// How much bonus a gap-fill placement earns.
// Large enough to override normal heuristic when the piece is THE one we want.
const GAP_FILL_BONUS=18000;

// Check if a placement (cells, x, dropY) for the current piece fills any
// known reachable gap. Returns the total bonus earned.
function gapFillBonus(cells,x,dropY){
  if(!cur||!gapList.length)return 0;
  const k=cur.k||Object.keys(PTYPES).find(k=>
    PTYPES[k].rgb[0]===cur.rgb[0]&&PTYPES[k].rgb[1]===cur.rgb[1]&&PTYPES[k].rgb[2]===cur.rgb[2]
  );
  if(!k)return 0;

  let bonus=0;
  for(const gap of gapList){
    if(!gap.reachable)continue;
    if(gap.pieceKey!==k)continue;
    // Same piece type â€” check if this placement footprint overlaps the gap
    // (i.e., the piece lands in or near the gap position)
    if(gap.x===x&&gap.dropY===dropY){
      bonus+=GAP_FILL_BONUS;
    }
  }
  return bonus;
}

// Returns a Set of "row,col" strings occupied by a placement
function footprint(cells,x,y){
  const fp=new Set();
  for(let r=0;r<cells.length;r++)
    for(let c=0;c<cells[r].length;c++)
      if(cells[r][c])fp.add(`${y+r},${x+c}`);
  return fp;
}

function setsOverlap(a,b){for(const k of a)if(b.has(k))return true;return false}

// â”€â”€â”€ BFS SLIDE DISCOVERY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// For the current piece, find ALL reachable landing positions â€” not just
// straight drops and single-step slides. Uses the same BFS as canReach but
// returns every (x, rot, dropY) that is:
//   (a) a legal resting state (piece can't move down further)
//   (b) reachable from the top
//   (c) NOT reachable by a straight vertical drop from x at row 0
//       (i.e., it truly requires lateral navigation to reach)
// Also returns the minimum number of lateral moves required (slide distance)
// so deeper slides earn more bonus.
function bfsAllReachable(pieceKey,rots,b=board){
  const isOkB=(c,x,y)=>isOk(c,x,y,b);
  // Visited array sized for max possible encode value: (COLS*(ROWS+4)+ROWS)*4
  // Extra headroom prevents out-of-bounds if a rotation has unexpected dimensions
  const VSIZE=(COLS*ROWS+ROWS)*4+16;
  const encode=(x,y,rot)=>(x*ROWS+y)*4+rot;
  const visited=new Uint8Array(VSIZE);
  const dist=new Uint16Array(VSIZE).fill(9999);

  const queue=[];
  for(let rot=0;rot<4;rot++){
    const cells=rots[rot];
    if(!cells||!cells[0]||!cells[0].length)continue;
    const pw=cells[0].length;
    for(let x=0;x<=COLS-pw;x++){
      if(isOkB(cells,x,0)){
        const key=encode(x,0,rot);
        if(key>=0&&key<VSIZE&&!visited[key]){visited[key]=1;dist[key]=0;queue.push([x,0,rot,0]);}
      }
    }
  }

  // Map of "resting positions only reachable via slide": key â†’ {x,rot,dropY,slideDist}
  const slideOnly=new Map();
  // Map of ALL resting positions (to compare against)
  const allRest=new Map();

  let qi=0;
  while(qi<queue.length){
    const[x,y,rot,lateral]=queue[qi++];
    const cells=rots[rot];
    if(!cells||!cells[0]||!cells[0].length)continue;
    const ph=cells.length,pw=cells[0].length;

    const resting=!isOkB(cells,x,y+1);
    if(resting){
      const rk=`${x},${rot},${y}`;
      if(!allRest.has(rk)||allRest.get(rk).slideDist>lateral)
        allRest.set(rk,{x,rot,dropY:y,slideDist:lateral});
    }

    if(y+1<ROWS&&isOkB(cells,x,y+1)){
      const key=encode(x,y+1,rot);
      if(key>=0&&key<VSIZE&&(!visited[key]||dist[key]>lateral)){visited[key]=1;dist[key]=lateral;queue.push([x,y+1,rot,lateral]);}
    }
    if(x>0&&isOkB(cells,x-1,y)){
      const key=encode(x-1,y,rot);
      const nd=lateral+1;
      if(key>=0&&key<VSIZE&&(!visited[key]||dist[key]>nd)){visited[key]=1;dist[key]=nd;queue.push([x-1,y,rot,nd]);}
    }
    if(x+pw<COLS&&isOkB(cells,x+1,y)){
      const key=encode(x+1,y,rot);
      const nd=lateral+1;
      if(key>=0&&key<VSIZE&&(!visited[key]||dist[key]>nd)){visited[key]=1;dist[key]=nd;queue.push([x+1,y,rot,nd]);}
    }
    const rotCW=(rot+1)%4;
    const cellsCW=rots[rotCW];
    if(cellsCW&&cellsCW[0]&&cellsCW[0].length&&x+cellsCW[0].length<=COLS&&isOkB(cellsCW,x,y)){
      const key=encode(x,y,rotCW);
      if(key>=0&&key<VSIZE&&(!visited[key]||dist[key]>lateral)){visited[key]=1;dist[key]=lateral;queue.push([x,y,rotCW,lateral]);}
    }
    const rotCCW=(rot+3)%4;
    const cellsCCW=rots[rotCCW];
    if(cellsCCW&&cellsCCW[0]&&cellsCCW[0].length&&x+cellsCCW[0].length<=COLS&&isOkB(cellsCCW,x,y)){
      const key=encode(x,y,rotCCW);
      if(key>=0&&key<VSIZE&&(!visited[key]||dist[key]>lateral)){visited[key]=1;dist[key]=lateral;queue.push([x,y,rotCCW,lateral]);}
    }
  }

  // Now find which resting positions require lateral movement (slide-only)
  const straightDrops=new Set();
  for(let rot=0;rot<4;rot++){
    const cells=rots[rot];
    if(!cells||!cells[0]||!cells[0].length)continue;
    const pw=cells[0].length;
    for(let x=0;x<=COLS-pw;x++){
      if(!isOkB(cells,x,0))continue;
      let gy=0;while(isOkB(cells,x,gy+1))gy++;
      straightDrops.add(`${x},${rot},${gy}`);
    }
  }

  const result=[];
  for(const[rk,info]of allRest){
    if(!straightDrops.has(rk)&&info.slideDist>0){
      result.push(info); // genuine slide-only landing
    }
  }
  return result;
}


function slideAdjustedBonus(cells,x,gy,dist){
  if(dist<=0||!cur)return 0;
  const tb=board.map(r=>[...r]);
  placeOn(tb,cells,x,gy,cur?cur.rgb:[255,255,255]);
  const[,nb]=simClear(tb);
  const holesBefore=countScoringHoles(board);
  const holesAfter=countScoringHoles(nb);
  const holeDelta=holesAfter-holesBefore;

  if(holeDelta>0){
    return -holeDelta*SLIDE_HOLE_PENALTY;
  }
  // Hole-neutral or hole-reducing â€” full slide bonus plus reduction reward
  return slideBonus(dist) + (-holeDelta)*HOLE_REDUCE_BONUS;
}

// Build all candidates for the current piece and store in allCands.
// fresh=true resets the "already shown" set (called on new piece spawn).
function calcPlacements(fresh=false){
  if(!cur)return;
  if(fresh){shownFootprints=new Set();playerHasMoved=false;moveStartTime=0;}

  // PROOF MODE: show normal AI options but mark the correct one yellow
  // Always compute the correct puzzle target so debug mode can be toggled
  // mid-game and instantly show the hint. Visual rendering is gated on PROOF_MODE.
  if(puzzleActive && puzzleTargets.length>0 && puzzleTargets[0]!==null){
    const t=puzzleTargets[0];
    let tx=t.x, trot=t.rot;
    // Only override rotation/x for the 10th piece (the Tetris well I-piece)
    if(t.k==='I' && puzzleTargets.length===1){
      const PUZZLE_TOP=ROWS-4;
      const openCol=Array.from({length:COLS},(_,c)=>c)
        .find(c=>board.slice(PUZZLE_TOP).every(row=>!row[c]));
      if(openCol!==undefined){ tx=openCol; trot=1; }
    }
    const correctCells=NRS[t.k][trot].map(r=>[...r]);
    let gy=0; while(isOk(correctCells,tx,gy+1)) gy++;
    const correctFp=Array.from(footprint(correctCells,tx,gy)).sort().join(';');
    window._proofCorrectFp=correctFp;
    window._proofCorrectCand={c:correctCells,x:tx,rotation:trot,dropY:gy,sc:999999,slide:false,fpKey:correctFp};
    const dbg=document.getElementById('proof-debug');
    if(dbg&&PROOF_MODE) dbg.textContent=`k=${t.k} rot=${trot} x=${tx} y=${gy} | targets=${puzzleTargets.length}`;
  } else {
    window._proofCorrectFp=null;
    window._proofCorrectCand=null;
  }

  // Build all 4 rotation states from NRS table (deduped by shape)
  const curKey=cur.k||Object.keys(PTYPES).find(k=>
    PTYPES[k].rgb[0]===cur.rgb[0]&&PTYPES[k].rgb[1]===cur.rgb[1]&&PTYPES[k].rgb[2]===cur.rgb[2]
  )||'I';
  const rots=NRS[curKey].map(r=>r.map(row=>[...row]));

  const cands=[];
  const fpSeen=new Set();

  const addCand=(cells,x,gy,ri,isSlide,sDist=0)=>{
    const fp=Array.from(footprint(cells,x,gy)).sort().join(';');
    if(fpSeen.has(fp))return; fpSeen.add(fp);
    const sc=evalP(cells,x,gy)+(isSlide?slideAdjustedBonus(cells,x,gy,sDist):0);
    cands.push({c:cells.map(r=>[...r]),x,rotation:ri,dropY:gy,sc,slide:isSlide,fpKey:fp});
  };

  // Straight drops
  for(let ri=0;ri<4;ri++){
    const cells=rots[ri];
    for(let x=0;x<=COLS-cells[0].length;x++){
      if(!isOk(cells,x,0))continue;
      let gy=0; while(isOk(cells,x,gy+1))gy++;
      addCand(cells,x,gy,ri,false);
    }
  }

  // BFS slide-only landings â€” finds 1-step, 2-step, mid-fall slides, all of it
  let slides=[];
  try{
    slides=bfsAllReachable(curKey,rots);
  }catch(e){console.error('bfsAllReachable crash:',e);slides=[];}

  // Evict any straight-drop candidate whose board footprint overlaps with
  // a slide candidate â€” BUT only if that slide is hole-neutral or better.
  const slideCells=new Set();
  for(const{x,rot,dropY}of slides){
    try{
      if(!rots[rot]||!rots[rot][0])continue;
      const tb=board.map(r=>[...r]);
      placeOn(tb,rots[rot],x,dropY,cur?cur.rgb:[255,255,255]);
      const[,nb]=simClear(tb);
      if(countBuriedCells(nb)<=countBuriedCells(board)){
        footprint(rots[rot],x,dropY).forEach(k=>slideCells.add(k));
      }
    }catch(e){console.error('slide eviction crash at rot='+rot+' x='+x+' dropY='+dropY,e);}
  }
  for(let i=cands.length-1;i>=0;i--){
    const ca=cands[i];
    if(ca.slide)continue;
    const fp=footprint(ca.c,ca.x,ca.dropY);
    let overlaps=false;
    for(const k of fp){if(slideCells.has(k)){overlaps=true;break;}}
    if(overlaps){
      fpSeen.delete(ca.fpKey);
      cands.splice(i,1);
    }
  }

  for(const{x,rot,dropY,slideDist}of slides){
    try{
      if(!rots[rot]||!rots[rot][0])continue;
      addCand(rots[rot],x,dropY,rot,true,slideDist);
    }catch(e){console.error('addCand slide crash at rot='+rot+' x='+x+' dropY='+dropY,e);}
  }

  cands.sort((a,b)=>b.sc-a.sc);

  // Always ensure the correct puzzle candidate is one of the 4 options,
  // whether or not debug mode is on. This guarantees the lottery is always
  // fair â€” 1-in-4 chance of picking right on any given piece by random guessing.
  // hint:true is only set when PROOF_MODE so the star only shows then.
  if(window._proofCorrectCand){
    const cc=window._proofCorrectCand;
    const idx=cands.findIndex(c=>c.fpKey===cc.fpKey);
    if(idx>=0) cands.splice(idx,1);
    cc.hint=PROOF_MODE; // star visible only in debug mode
    cands.unshift(cc);
    fpSeen.add(cc.fpKey);
  }

  allCands=cands;
  applyNextOptions();
}

// Pick up to 4 non-overlapping options from allCands, skipping shownFootprints.
// If sdCand is provided it is reserved as the first slot (straight-drop guarantee).
function pickOptions(sdCand, sdFp){
  const chosen=[];
  const usedCells=new Set();

  if(sdCand){
    chosen.push(sdCand);
    footprint(sdCand.c,sdCand.x,sdCand.dropY).forEach(k=>usedCells.add(k));
  }

  for(const ca of allCands){
    if(chosen.length>=4)break;
    if(ca.fpKey===sdFp)continue;          // already have this one
    if(shownFootprints.has(ca.fpKey))continue;
    const fp=footprint(ca.c,ca.x,ca.dropY);
    if(!setsOverlap(fp,usedCells)){
      chosen.push(ca);
      fp.forEach(k=>usedCells.add(k));
    }
  }
  return chosen;
}

function applyNextOptions(){
  // â”€â”€ TETRIS LOCK: if any candidate clears exactly 4 lines right now,
  //    show ONLY that placement â€” no other options, no cycling. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const tetrisCand=_findTetrisCand();
  if(tetrisCand){
    placements=[tetrisCand,null,null,null];
    shownFootprints.clear();
    shownFootprints.add(tetrisCand.fpKey);
    for(let i=0;i<4;i++)drawPrevBtn(i,placements[i]);
    showTetrisButton();
    return;
  }
  hideTetrisButton();

  // â”€â”€ Compute straight-drop candidate (only after player has moved) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let sdCand=null, sdFp=null;
  if(playerHasMoved){
    let sy=cy; while(isOk(cur.c,cx,sy+1))sy++;
    sdFp=Array.from(footprint(cur.c,cx,sy)).sort().join(';');
    sdCand=allCands.find(c=>c.fpKey===sdFp);
    if(!sdCand){
      sdCand={c:cur.c.map(r=>[...r]),x:cx,rotation:0,dropY:sy,
              sc:evalP(cur.c,cx,sy),slide:false,fpKey:sdFp};
    }
  }

  // â”€â”€ Fill up to 4 slots, wrapping the shown-set if needed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let chosen=pickOptions(sdCand,sdFp);

  if(chosen.length<(sdCand?2:1)){
    shownFootprints=new Set();
    chosen=pickOptions(sdCand,sdFp);
  }

  for(const ca of chosen)shownFootprints.add(ca.fpKey);

  chosen.sort((a,b)=>a.x-b.x);
  while(chosen.length<4)chosen.push(null);
  placements=chosen;
  for(let i=0;i<4;i++)drawPrevBtn(i,placements[i]);
}

// â”€â”€ Tetris button show/hide â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showTetrisButton(){
  document.getElementById('prow').style.display='none';
  document.getElementById('tetris-btn').style.display='block';
}
function hideTetrisButton(){
  document.getElementById('prow').style.display='flex';
  document.getElementById('tetris-btn').style.display='none';
}

// Called when the player taps the big TETRIS button
function chooseTetris(){
  if(dead||paused||clearAnimating||!cur)return;
  const tc=_findTetrisCand();
  if(!tc)return;
  stopSelTimer();stopDrop();
  cur.c=tc.c;cx=tc.x;cy=tc.dropY;
  sndTetrisBlip();
  lock();
}

// Return the first candidate that clears exactly 4 lines, or null.
function _findTetrisCand(){
  for(const ca of allCands){
    const tb=board.map(r=>[...r]);
    placeOn(tb,ca.c,ca.x,ca.dropY,cur?cur.rgb:[255,255,255]);
    const cl=tb.filter(r=>r.every(v=>v)).length;
    if(cl===4)return ca;
  }
  return null;
}

// Called when player taps the board outside a label â€” cycle to fresh set of options.
// Blocked when a Tetris is available â€” no escape from that.
function cycleOptions(){
  if(dead||paused||!allCands.length)return;
  if(_findTetrisCand())return; // Tetris is on the table â€” no cycling allowed
  applyNextOptions();
}

function choose(i){
  if(dead||paused||clearAnimating||!cur)return;
  const p=placements[i];if(!p)return;
  stopSelTimer();stopDrop();
  cur.c=p.c;cx=p.x;cy=p.dropY;
  lock();
}

function lock(){
  if(!cur)return; // guard against double-lock races
  stopSelTimer();stopDrop();
  sndLock();
  // Consume proof mode target for this piece
  if(puzzleTargets.length>0) puzzleTargets.shift();
  placeOn(board,cur.c,cx,cy,cur.rgb);
  cur=null; // â† hide the piece immediately so it never renders during explosion
  placements=[null,null,null,null]; // â† invalidate stale candidates immediately
  for(let i=0;i<4;i++)drawPrevBtn(i,null); // â† clear button displays now

  // Scan for complete rows NOW, while board is settled
  const completeRows=[];
  for(let r=ROWS-1;r>=0;r--)if(board[r].every(v=>v))completeRows.push(r);

  if(completeRows.length===0){
    piecesPlaced++;
    addScore(0);
    rebuildGapList();
    updateTetrisPrepStrategy();
    checkNoHoleBonus();
    spawn();scheduleDrop();
  } else {
    animateClearLines(completeRows,()=>{
      const toRemove=[];
      for(let r=ROWS-1;r>=0;r--)if(board[r].every(v=>v))toRemove.push(r);
      toRemove.sort((a,b)=>b-a);
      for(const r of toRemove)board.splice(r,1);
      for(let i=0;i<toRemove.length;i++)board.unshift(Array(COLS).fill(null));
      const cleared=toRemove.length||completeRows.length;
      piecesPlaced++;
      addScore(cleared);
      rebuildGapList();
      updateTetrisPrepStrategy();

      const tetrisPoints=NES_SC[Math.min(cleared,4)]*level;
      if(cleared===4){
        // Perfect board on move 10: board is empty after Tetris
        const boardEmpty=board.every(row=>row.every(v=>!v));
        if(boardEmpty&&piecesPlaced<=10){
          score+=20490;
          document.getElementById('sv').textContent=score;
          sndTetrisPerfection();
          tickerPush([`ğŸ‘¾ ATARI OG`, `+20,490`, `â‰¤10 PCS CLEAR`]);
          txScore('atari-og',20490,[
            {label:'Atari OG Bonus','value':''},
            {label:'Perfect Tetris in <=10 pieces','value':''},
            {label:'SF Rush 2049 tribute','value':'+20,490'},
          ]);
        }
        fanfare(tetrisPoints);
      } else {
        // Non-Tetris clear: award hole-fractional piecePot bonus
        awardLineClearBonus(cleared, completeRows);
        // Break streak, reset multiplier, zero tetrisPot
        tetrisStreak=0;
        tetrisMultiplier=1;
        
        tetrisPot=0;
        updateTBDisplay();
      }
      // After any line clear, reset scoring-hole check so next call
      // treats the new board state as a fresh evaluation.
      _lastScoringHoleCheck=false;

      // Always run checkNoHoleBonus after any clear â€” both Tetris and non-Tetris
      checkNoHoleBonus();
      spawn();scheduleDrop();
    });
  }
}

// â”€â”€ EXPLOSION ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function explodeBlock(col,row,rgb){
  const[r,g,b]=rgb;
  const bx=col*CELL,by=row*CELL;
  for(let i=0;i<120;i++){
    const ang=Math.random()*Math.PI*2;
    const spd=(Math.random()*3.2+0.4)*(CELL/24);
    particles.push({
      x:bx+Math.random()*CELL,y:by+Math.random()*CELL,
      vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,
      r,g,b,
      life:1,decay:0.022+Math.random()*0.028,
      sz:Math.random()*3+1
    });
  }
}

const COL_ORDER=[4,5,3,6,2,7,1,8,0,9];

function _clearAnimMs(){
  // Two-scale speed control:
  // Speed 1-5: interpolate from 3x slower to normal (1x)
  // Speed 5-11: interpolate from normal (1x) to 10x faster
  // Base step = 50/n ms, base pause = n===4?320:130 ms
  const s=AUTO_SPEED;
  let mult;
  if(s<=5){
    // 1â†’5: mult goes 3.0â†’1.0
    mult=3.0-(s-1)*0.5;
  } else {
    // 5â†’11: mult goes 1.0â†’0.1 (10x faster = 90% reduction)
    mult=1.0-(s-5)*(0.9/6);
  }
  return mult;
}

function animateClearLines(rowIndices,onComplete){
  clearAnimating=true;
  explodedCells.clear();
  const n=rowIndices.length;
  const mult=_clearAnimMs();
  const stepMs=Math.max(2, Math.round((50/n)*mult));
  const pauseMs=Math.max(8, Math.round((n===4?320:130)*mult));
  const rowsSorted=[...rowIndices].sort((a,b)=>b-a);

  let step=0;
  const doStep=()=>{
    if(step>=COL_ORDER.length){
      sndLineClear(n);
      explodedCells.clear();
      setTimeout(()=>{
        clearAnimating=false;
        onComplete();
      },pauseMs);
      return;
    }
    const col=COL_ORDER[step];
    rowsSorted.forEach((row,ri)=>{
      if(board[row][col]){
        explodedCells.add(`${row},${col}`);
        explodeBlock(col,row,board[row][col]);
        sndBlockPop(ri,step);
      }
    });
    step++;
    setTimeout(doStep,stepMs);
  };
  doStep();
}

function addScore(cl){
  const prevLevel=level;
  // NES base line-clear points removed â€” scoring handled by T-bonus pot fractions
  lines+=cl;
  const nl=Math.floor(lines/10)+1;if(nl>level)level=nl;
  document.getElementById('sv').textContent=score;
  document.getElementById('lv').textContent=level;
  document.getElementById('lnv').textContent=lines;
  if(!autoUsed && score>hi){hi=score;document.getElementById('hv').textContent=hi}
  if(level>prevLevel)setTimeout(sndLevelUp,cl>0?520:0);
}

// â”€â”€â”€ CONTROLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rot(d){
  if(dead||paused||clearAnimating||!cur)return;
  const next=rotNRS(cur,d);
  const r=next.c;
  // Try center position, then kick Â±1, then Â±2 (allows rotating into slots)
  if(isOk(r,cx,cy)){
    cur.c=r;cur.rot=next.rot;
  } else if(isOk(r,cx-1,cy)){
    cur.c=r;cur.rot=next.rot;cx--;
  } else if(isOk(r,cx+1,cy)){
    cur.c=r;cur.rot=next.rot;cx++;
  } else if(isOk(r,cx-2,cy)){
    cur.c=r;cur.rot=next.rot;cx-=2;
  } else if(isOk(r,cx+2,cy)){
    cur.c=r;cur.rot=next.rot;cx+=2;
  } else return; // rotation genuinely blocked
  playerHasMoved=true;moveStartTime=AT;
  sndRotate();calcPlacements();scheduleDrop();
}
function mhz(d){
  if(dead||paused||clearAnimating||!cur)return;
  if(!isOk(cur.c,cx+d,cy))return;
  cx+=d;playerHasMoved=true;moveStartTime=AT;sndMove();calcPlacements();scheduleDrop();
}
function sdrop(){
  if(dead||paused||clearAnimating||!cur)return;
  if(isOk(cur.c,cx,cy+1)){cy++;score++;sndSoftDrop();document.getElementById('sv').textContent=score;scheduleDrop();}
}
function hdrop(){
  if(dead||paused||clearAnimating||!cur)return;
  stopSelTimer();stopDrop();
  sndHardDrop();
  let dr=0;while(isOk(cur.c,cx,cy+1)){cy++;dr++}
  lock();
}

// â”€â”€â”€ TIMERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function scheduleDrop(){
  clearInterval(dropIv);if(dead)return;
  const sp=NES_SP[Math.min(level-1,NES_SP.length-1)];
  dropIv=setInterval(()=>{
    if(paused||dead||clearAnimating||!cur)return;
    if(isOk(cur.c,cx,cy+1))cy++;
    else{stopDrop();lock();}
  },sp);
}
function stopDrop(){clearInterval(dropIv);}

// â”€â”€ Auto-play animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Starts immediately on spawn. Executes: rotate â†’ strafe â†’ drop.
// Player can interrupt at any time by tapping a button (stopSelTimer cancels).
let _autoIv=null;
let _autoPhase=null; // {targetIdx, targetX, targetRot, isSlide, steps:[]}

function startSelTimer(){
  clearInterval(selIv);clearInterval(_autoIv);_autoPhase=null;
  timerMax=Math.max(3000,15000-(level-1)*800);
  timerLeft=timerMax;

  // Countdown (for any external timer bar display)
  selIv=setInterval(()=>{
    if(paused||dead||clearAnimating)return;
    timerLeft-=100;
    if(timerLeft<=0){ stopSelTimer(); if(!dead&&!clearAnimating) autoChooseBest(); }
  },100);

  // Initial delay scales with speed: 600ms at speed 1, 0ms at speed 11
  const startDelay = Math.round(600 * (1 - (AUTO_SPEED-1)/10));
  setTimeout(()=>{
    if(!dead&&!paused&&!clearAnimating&&cur&&AUTO_PLAY) _startAutoPlay();
  }, startDelay);
}

function stopSelTimer(){
  clearInterval(selIv);
  clearInterval(_autoIv);
  _autoIv=null;
  _autoPhase=null;
}

// â”€â”€ BFS pathfinder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Finds shortest move sequence ['L','R','D','CW'] from (startX,startRot,startY)
// to a state where piece has rotation=targetRot, x=targetX, and can't drop further.
// Uses live board â€” respects all current terrain.
function _bfsPath(startX, startRot, startY, targetX, targetRot, pieceKey){
  const encode=(x,r,y)=>(y*40+x)*8+r; // compact int key
  const start=encode(startX,startRot,startY);
  const visited=new Map([[start,null]]); // key -> {parentKey, move}
  const queue=[{x:startX,r:startRot,y:startY,key:start}];
  const getCells=(r)=>NRS[pieceKey][r%4];
  const kicks=[0,-1,1,-2,2];
  let found=null;
  let iters=0;

  while(queue.length && iters++<12000){
    const {x,r,y,key}=queue.shift();
    const cells=getCells(r);

    // Goal: correct rotation and x, resting on surface
    if(r===targetRot && x===targetX && !isOk(cells,x,y+1)){
      found=key; break;
    }

    const enqueue=(nx,nr,ny,move)=>{
      const nk=encode(nx,nr,ny);
      if(visited.has(nk))return;
      visited.set(nk,{parentKey:key,move});
      queue.push({x:nx,r:nr,y:ny,key:nk});
    };

    // Drop â€” always valid if space
    if(isOk(cells,x,y+1)) enqueue(x,r,y+1,'D');
    // Strafe
    if(isOk(cells,x-1,y)) enqueue(x-1,r,y,'L');
    if(isOk(cells,x+1,y)) enqueue(x+1,r,y,'R');
    // Rotate CW with wall kicks + pivot correction
    const nr=(r+1)%4;
    const nc=getCells(nr);
    const pdx=(PIVOT_DX[pieceKey]||[0,0,0,0])[r];
    for(const k of kicks){
      const px=x+pdx+k;
      if(isOk(nc,px,y)){ enqueue(px,nr,y,'CW'); break; }
    }
  }

  if(!found) return null;

  // Reconstruct path by walking back through visited map
  const path=[];
  let k=found;
  while(true){
    const entry=visited.get(k);
    if(!entry || entry.move===undefined) break;
    path.unshift(entry.move);
    k=entry.parentKey;
  }
  return path;
}

// â”€â”€ Auto-play: BFS â†’ token stream â†’ smooth replay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _startAutoPlay(){
  if(!cur||dead||paused||clearAnimating)return;

  // Pick highest-scoring slot
  let bestIdx=0, bestSc=-Infinity;
  for(let i=0;i<4;i++){
    const p=placements[i];
    if(p&&p.sc>bestSc){ bestSc=p.sc; bestIdx=i; }
  }
  const best=placements[bestIdx];
  if(!best)return;

  const pieceKey=cur.k||'I';

  // BFS from current live position
  const path=_bfsPath(cx, cur.rot||0, cy, best.x, best.rotation, pieceKey);

  if(!path || path.length===0){
    // Unreachable or already there â€” commit immediately
    choose(bestIdx); return;
  }

  // Stop gravity during animation â€” we control all movement
  stopDrop();

  // Speed mapping: 1=180ms/step, 11=~15ms with frame-skipping
  // At speed 11 we draw only 1 in 4 frames by batching 4 moves per setTimeout
  const speedFactor = AUTO_SPEED; // 1..11
  const baseMoveMs  = Math.round(180 - (speedFactor-1) * 15); // 180â†’15ms
  const frameSkip   = speedFactor >= 11 ? 4 : speedFactor >= 9 ? 2 : 1;
  const MS={CW:0, L:baseMoveMs, R:baseMoveMs, D: best.slide ? Math.round(baseMoveMs*0.4) : Math.round(baseMoveMs*0.55)};

  let idx=0;

  const execMove=(move)=>{
    const rot=cur.rot||0;
    const pivDx=(PIVOT_DX[pieceKey]||[0,0,0,0]);
    const kicks=[0,-1,1,-2,2];
    if(move==='CW'){
      const nr=(rot+1)%4;
      const nc=NRS[pieceKey][nr];
      const pdx=pivDx[rot];
      for(const k of kicks){
        const px=cx+pdx+k;
        if(isOk(nc,px,cy)){
          cur.c=nc.map(r=>[...r]); cur.rot=nr; cx=px; break;
        }
      }
    } else if(move==='L'){
      if(isOk(cur.c,cx-1,cy)) cx--;
    } else if(move==='R'){
      if(isOk(cur.c,cx+1,cy)) cx++;
    } else if(move==='D'){
      if(isOk(cur.c,cx,cy+1)) cy++;
    }
  };

  const step=()=>{
    if(dead||paused||clearAnimating||!cur){ clearTimeout(_autoIv); return; }

    if(idx>=path.length){
      const btn=document.getElementById('pb'+bestIdx);
      if(btn){
        btn.style.boxShadow='0 0 32px #fff,0 0 56px #ffff00';
        setTimeout(()=>{ if(btn)btn.style.boxShadow=''; },300);
      }
      const commitDelay = Math.round(150 * (1 - (AUTO_SPEED-1)/10));
      setTimeout(()=>{ if(!dead&&!paused&&cur) choose(bestIdx); },commitDelay);
      return;
    }

    // Execute frameSkip moves per tick (batched at high speed)
    // Rotations (CW=0ms) are always consumed immediately regardless of frameSkip
    let drawn=0;
    while(idx<path.length && (drawn<frameSkip || path[idx]==='CW')){
      const move=path[idx++];
      execMove(move);
      if(move!=='CW') drawn++;
    }

    _autoIv=setTimeout(step, idx<path.length ? MS[path[idx]]||baseMoveMs : 150);
  };

  // Kick off â€” first step after a brief "thinking" pause
  _autoIv=setTimeout(step, MS[path[0]]);
}

// Fallback: if timer fully expires without auto-play finishing, force commit
function autoChooseBest(){
  if(dead||paused||clearAnimating||!cur)return;
  clearTimeout(_autoIv); _autoIv=null;
  if(!AUTO_PLAY){
    // NES mode: straight drop from current position, no lateral movement
    while(isOk(cur.c,cx,cy+1)) cy++;
    lock(); return;
  }
  let bestIdx=0, bestSc=-Infinity;
  for(let i=0;i<4;i++){
    const p=placements[i];
    if(p&&p.sc>bestSc){ bestSc=p.sc; bestIdx=i; }
  }
  choose(bestIdx);
}

function toggleAutoPlay(){
  AUTO_PLAY=!AUTO_PLAY;
  if(AUTO_PLAY) autoUsed=true; // turning on auto disqualifies this game's score
  const lbl=document.getElementById('ap-toggle-label');
  if(lbl) lbl.classList.toggle('on',AUTO_PLAY);
  if(!AUTO_PLAY){ clearTimeout(_autoIv); _autoIv=null; }
}

function setAutoSpeed(v){
  AUTO_SPEED=parseInt(v);
  const el=document.getElementById('ap-speed-val');
  if(el) el.textContent=AUTO_SPEED===11?'11ğŸ”Š':String(AUTO_SPEED);
}

function _syncAutoUI(){
  const lbl=document.getElementById('ap-toggle-label');
  if(lbl) lbl.classList.toggle('on',AUTO_PLAY);
  const sv=document.getElementById('ap-speed-val');
  if(sv) sv.textContent=AUTO_SPEED===11?'11ğŸ”Š':String(AUTO_SPEED);
}

// â”€â”€â”€ FANFARE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function floatTetrisBonus(amount){
  const cs=Math.round(piecePot/100);
  tickerPush([fmtK(amount), `${cs}CS 4T`]);
  // Also briefly flash the tb-float for visibility
  const el=document.getElementById('tb-float');
  if(!el)return;
  el.textContent='+'+amount.toLocaleString();
  el.style.opacity='1';
  el.style.transition='none';
  el.style.bottom='4px';
  let startT=Date.now();
  const tick=()=>{
    const e=(Date.now()-startT)/1000;
    el.style.opacity=String(Math.max(0,1-e/1.2));
    el.style.bottom=(4+e*20)+'px';
    if(e<1.2)requestAnimationFrame(tick);
    else el.style.opacity='0';
  };
  requestAnimationFrame(tick);
}

function updateTBDisplay(){
  const ep=document.getElementById('tbv-pieces');
  const et=document.getElementById('tbv-tetris');
  // CLEAN: number of clean pieces placed (piecePot Ã· 100, since each piece adds 100)
  if(ep) ep.textContent=Math.round(piecePot/100).toLocaleString();
  // TETRIS: compact K format (drop trailing zeros, add K)
  if(et){
    const v=tetrisPot;
    et.textContent=v>=1000?(v/1000)+'k':v.toString();
  }
}

function fanfare(tetrisPoints){
  // board shake only
  const sw=document.getElementById('sw');
  // (shake animation removed â€” canvas handles visual feedback)

  tetrisStreak++;

  // Collect both pots into score NOW (before adding next virtual credit)
  const collected = piecePot + tetrisPot;
  if(collected > 0){
    score += collected;
    document.getElementById('sv').textContent=score;
    // Ticker fanfare â€” streak indicator via gem emojis (1 per streak, max 5)
    const gems=['ğŸ’','ğŸ’ğŸ’','ğŸ’ğŸ’ğŸ’','ğŸ’ğŸ’ğŸ’ğŸ’','ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’'];
    const gemStr=gems[Math.min(tetrisStreak-1,4)];
    const cs=Math.round(piecePot/100);
    tickerPush([`ğŸ¯ TETRIS ${gemStr}`, fmtK(collected), `${cs}CS 4T`]);
    txScore('tetris', collected, [
      {label:'Piece pot',        value: fmtAmt(piecePot)},
      {label:'Tetris streak pot',value: fmtAmt(tetrisPot)},
      {label:'Streak x'+tetrisStreak+' (mult '+tetrisMultiplier+'x)', value:''},
      {label:'Total collected',  value: fmtAmt(collected)},
    ]);
  } else {
    tickerPush([`ğŸ¯ TETRIS`, `4T 0 bonus`]);
  }

  // piecePot carries over through Tetrises â€” only holes reset it

  // Add virtual credit for next Tetris at CURRENT multiplier (before doubling)
  // Tetris #1 (mult=1): +2,000 â†’ display 2,000
  // Tetris #2 (mult=2): +4,000 â†’ display 6,000
  // Tetris #3 (mult=4): +8,000 â†’ display 14,000
  const virtualCredit = Math.min(20 * 100 * tetrisMultiplier, 32000);
  tetrisPot += virtualCredit;

  // Now double multiplier (cap at 16) â€” next pieces earn at new rate
  tetrisMultiplier = Math.min(tetrisMultiplier * 2, 16);

  updateTBDisplay();

  // After Tetris, re-evaluate scoring holes on current board
  currentScoringHoles=countScoringHoles(board);
  updateHoleDisplay(currentScoringHoles);
  _lastScoringHoleCheck=(currentScoringHoles===0);

}

// â”€â”€â”€ GAME OVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerDead(){
  dead=true;stopDrop();stopSelTimer();
  sndGameOver();
  // Only update high score on human games (no auto used)
  if(!autoUsed && score>hi){
    hi=score;
    document.getElementById('hv').textContent=hi;
  }
  const qualifier = autoUsed ? ' Â· AUTO (no hi score)' : (score>=hi&&score>0?' Â· NEW HIGH!':'');
  document.getElementById('fst').textContent='Score: '+score+qualifier;
  document.getElementById('gov').style.display='flex';
}

function togglePause(){
  if(dead)return;paused=!paused;
  document.getElementById('pov').style.display=paused?'flex':'none';
}

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function init(){
  board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
  score=0;level=1;lines=0;dead=false;paused=false;
  particles=[];explodedCells.clear();clearAnimating=false;
  gapList=[];tetrisPrepActive=false;tetrisPrepCol=-1;
  piecePot=0;tetrisPot=0;piecesPlaced=0;_lastScoringHoleCheck=false;
  tetrisStreak=0;tetrisMultiplier=1;
  currentScoringHoles=0;scoringDisabledSound=false;
  hfRun=0;hfBest=0;
  _towerSeverity=0;
  autoUsed=false;
  _gamesPlayed++;
  _tickerInit();
  setTimeout(()=>{ try{tickerPush([`READY`,`LVL ${level}`]);}catch(e){} }, 100);
  updateHoleDisplay(0);updateTBDisplay();
  txReset();
  puzzleQueue=[];puzzleTargets=[];puzzleActive=false;buildPuzzleQueue();
  hideTetrisButton();
  document.getElementById('sv').textContent='0';
  document.getElementById('lv').textContent='1';
  document.getElementById('lnv').textContent='0';
  document.getElementById('hv').textContent=hi;
  document.getElementById('gov').style.display='none';
  document.getElementById('pov').style.display='none';
  // Always spawn â€” start screen gated by ui.gameStarted in renderer
  nxt=mkPiece();spawn();scheduleDrop();
}
function startGame(){
  dbg('startGame called');
  // Fire init immediately â€” don't block on AudioContext.resume()
  // iOS audio will work on first sound because we're inside the gesture
  ui.gameStarted = true;
  try{
    // Create AC now while inside gesture handler so iOS allows it
    if(!AC) AC = new(window.AudioContext||window.webkitAudioContext)();
    if(AC.state==='suspended') AC.resume(); // fire-and-forget, don't await
  }catch(e){ dbg('AC warn: '+e.message); }
  try{
    dbg('init starting...');
    init();
    dbg('init done');
    _syncAutoUI();
    dbg('game running');
  }catch(e){
    dbg('ERR init: '+e.message);
    console.error(e);
  }
}

function _showErr(e){ console.error(e); }

function restart(){
  try{ stopDrop();stopSelTimer();init(); }
  catch(e){ console.error(e); }
}

// â”€â”€â”€ KEYBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('keydown',e=>{
  if(dead)return;
  if(e.key==='ArrowLeft')mhz(-1);
  else if(e.key==='ArrowRight')mhz(1);
  else if(e.key==='ArrowDown')sdrop();
  else if(e.key==='ArrowUp'||e.key==='x'||e.key==='X')rot(1);
  else if(e.key==='z'||e.key==='Z')rot(-1);
  else if(e.key===' '){hdrop();e.preventDefault()}
  else if(e.key==='p'||e.key==='P')togglePause();
  else if(e.key==='1')choose(0);
  else if(e.key==='2')choose(1);
  else if(e.key==='3')choose(2);
  else if(e.key==='4')choose(3);
});

// â”€â”€â”€ CANVAS TAP / CLICK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleCanvasTap(clientX,clientY){
  if(dead||paused||!placements)return;
  const rect=gc.getBoundingClientRect();
  const scaleX=gc.width/rect.width, scaleY=gc.height/rect.height;
  const mx=(clientX-rect.left)*scaleX;
  const my=(clientY-rect.top)*scaleY;
  // Hit radius: 1.8 Ã— cell so numbers are easy to tap on small screens
  const hitR=CELL*1.8;
  for(const lp of labelPositions){
    const dx=mx-lp.x, dy=my-lp.y;
    if(dx*dx+dy*dy<hitR*hitR){ choose(lp.idx); return; }
  }
  // Tapped outside any label â€” cycle to fresh set of options
  cycleOptions();
}


let txLog = [];
let txRunningTotal = 0;

function txReset(){
  txLog = [];
  txRunningTotal = 0;
  txLog.push({ type:'session-start', ts: Date.now() });
}

// eventType: string key  |  amount: number  |  breakdown: [{label,value}]
function txScore(eventType, amount, breakdown){
  txRunningTotal += amount;
  txLog.push({
    type: 'score',
    eventType,
    amount,
    breakdown: breakdown || [],
    running: txRunningTotal
  });
}

function txMilestone(label){
  txLog.push({ type:'milestone', label, running: txRunningTotal });
}

// â”€â”€ Dot-matrix canvas font â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5Ã—7 bitmap font.  Each char = 5 column bytes, bit0=row0(top).
const DM_FONT = (()=>{
  const F = {};
  const d = (c,...v) => { F[c] = v; };
  d(' ',0x00,0x00,0x00,0x00,0x00);
  d('!',0x00,0x00,0x5F,0x00,0x00);
  d('"',0x00,0x07,0x00,0x07,0x00);
  d('#',0x14,0x7F,0x14,0x7F,0x14);
  d('$',0x24,0x2A,0x7F,0x2A,0x12);
  d('%',0x23,0x13,0x08,0x64,0x62);
  d('&',0x36,0x49,0x55,0x22,0x50);
  d("'",0x00,0x05,0x03,0x00,0x00);
  d('(',0x00,0x1C,0x22,0x41,0x00);
  d(')',0x00,0x41,0x22,0x1C,0x00);
  d('*',0x08,0x2A,0x1C,0x2A,0x08);
  d('+',0x08,0x08,0x3E,0x08,0x08);
  d(',',0x00,0x50,0x30,0x00,0x00);
  d('-',0x08,0x08,0x08,0x08,0x08);
  d('.',0x00,0x60,0x60,0x00,0x00);
  d('/',0x20,0x10,0x08,0x04,0x02);
  d('0',0x3E,0x51,0x49,0x45,0x3E);
  d('1',0x00,0x42,0x7F,0x40,0x00);
  d('2',0x42,0x61,0x51,0x49,0x46);
  d('3',0x21,0x41,0x45,0x4B,0x31);
  d('4',0x18,0x14,0x12,0x7F,0x10);
  d('5',0x27,0x45,0x45,0x45,0x39);
  d('6',0x3C,0x4A,0x49,0x49,0x30);
  d('7',0x01,0x71,0x09,0x05,0x03);
  d('8',0x36,0x49,0x49,0x49,0x36);
  d('9',0x06,0x49,0x49,0x29,0x1E);
  d(':',0x00,0x36,0x36,0x00,0x00);
  d(';',0x00,0x56,0x36,0x00,0x00);
  d('<',0x08,0x14,0x22,0x41,0x00);
  d('=',0x14,0x14,0x14,0x14,0x14);
  d('>',0x00,0x41,0x22,0x14,0x08);
  d('?',0x02,0x01,0x51,0x09,0x06);
  d('@',0x32,0x49,0x79,0x41,0x3E);
  d('A',0x7E,0x11,0x11,0x11,0x7E);
  d('B',0x7F,0x49,0x49,0x49,0x36);
  d('C',0x3E,0x41,0x41,0x41,0x22);
  d('D',0x7F,0x41,0x41,0x22,0x1C);
  d('E',0x7F,0x49,0x49,0x49,0x41);
  d('F',0x7F,0x09,0x09,0x09,0x01);
  d('G',0x3E,0x41,0x49,0x49,0x7A);
  d('H',0x7F,0x08,0x08,0x08,0x7F);
  d('I',0x00,0x41,0x7F,0x41,0x00);
  d('J',0x20,0x40,0x41,0x3F,0x01);
  d('K',0x7F,0x08,0x14,0x22,0x41);
  d('L',0x7F,0x40,0x40,0x40,0x40);
  d('M',0x7F,0x02,0x04,0x02,0x7F);
  d('N',0x7F,0x04,0x08,0x10,0x7F);
  d('O',0x3E,0x41,0x41,0x41,0x3E);
  d('P',0x7F,0x09,0x09,0x09,0x06);
  d('Q',0x3E,0x41,0x51,0x21,0x5E);
  d('R',0x7F,0x09,0x19,0x29,0x46);
  d('S',0x46,0x49,0x49,0x49,0x31);
  d('T',0x01,0x01,0x7F,0x01,0x01);
  d('U',0x3F,0x40,0x40,0x40,0x3F);
  d('V',0x1F,0x20,0x40,0x20,0x1F);
  d('W',0x3F,0x40,0x38,0x40,0x3F);
  d('X',0x63,0x14,0x08,0x14,0x63);
  d('Y',0x07,0x08,0x70,0x08,0x07);
  d('Z',0x61,0x51,0x49,0x45,0x43);
  d('[',0x00,0x7F,0x41,0x41,0x00);
  d('\\',0x02,0x04,0x08,0x10,0x20);
  d(']',0x00,0x41,0x41,0x7F,0x00);
  d('_',0x40,0x40,0x40,0x40,0x40);
  d('.',0x00,0x60,0x60,0x00,0x00);
  d(',',0x00,0x50,0x30,0x00,0x00);
  // lowercase maps to uppercase for thermal caps style
  'abcdefghijklmnopqrstuvwxyz'.split('').forEach((c,i)=>{
    F[c] = F[String.fromCharCode(65+i)] || F[' '];
  });
  return F;
})();

// Pixel sizes
const DM_DOT = 2;   // filled square per dot
const DM_GAP = 1;   // white gap between dots
const DM_STEP = DM_DOT + DM_GAP;   // 3px total per cell
const DM_CHAR_W = 5 * DM_STEP + DM_GAP; // width of one char incl. right gap
const DM_CHAR_H = 7 * DM_STEP;          // height of char
const DM_LINE_H = DM_CHAR_H + DM_STEP;  // line height with descender gap
const DM_COLS = 38;  // max chars per receipt line

// Render one line of text to a canvas element
function dmRender(text, opts){
  const inv   = (opts&&opts.inv)   || false;
  const bold  = (opts&&opts.bold)  || false;
  const scale = (opts&&opts.scale) || 1;
  const padX  = 6;
  const padY  = 4;

  const str = String(text).toUpperCase().substring(0, DM_COLS);
  const W = padX * 2 + str.length * DM_CHAR_W;
  const H = padY * 2 + DM_LINE_H;

  const cv = document.createElement('canvas');
  cv.width  = Math.ceil(W * scale);
  cv.height = Math.ceil(H * scale);
  cv.style.width  = '100%';
  cv.style.height = Math.ceil(H * scale) + 'px';
  cv.style.display = 'block';
  cv.style.imageRendering = 'pixelated';

  const ctx = cv.getContext('2d');
  ctx.scale(scale, scale);

  // Paper background
  ctx.fillStyle = inv ? '#1a1008' : '#f5f0e8';
  ctx.fillRect(0, 0, W, H);

  const ink = inv ? '#f0e8d0' : '#1a1008';
  ctx.fillStyle = ink;

  for (let ci = 0; ci < str.length; ci++) {
    const ch = str[ci];
    const glyph = DM_FONT[ch] || DM_FONT[' '];
    const ox = padX + ci * DM_CHAR_W;
    const oy = padY;
    for (let col = 0; col < 5; col++) {
      const colBits = glyph[col] || 0;
      for (let row = 0; row < 7; row++) {
        if (colBits & (1 << row)) {
          const px = ox + col * DM_STEP;
          const py = oy + row * DM_STEP;
          ctx.fillRect(px, py, DM_DOT, DM_DOT);
          if (bold) {
            // Bold = extra dot to the right
            ctx.fillRect(px + 1, py, DM_DOT, DM_DOT);
          }
        }
      }
    }
  }
  return cv;
}

// Convenience: wrap canvas in a div
function dmLine(text, opts) {
  const wrap = document.createElement('div');
  wrap.style.cssText = 'width:100%;overflow:hidden;margin:0;padding:0;line-height:0';
  wrap.appendChild(dmRender(text, opts));
  return wrap;
}

function dmSpacer(px) {
  const d = document.createElement('div');
  d.style.cssText = `height:${px||5}px;width:100%;background:#f5f0e8`;
  return d;
}

// Left+right justified row: left text, right text, total DM_COLS wide
function dmRow(left, right) {
  const r = String(right || '');
  const l = String(left  || '').substring(0, DM_COLS - r.length - 1);
  const gap = DM_COLS - l.length - r.length;
  return l + ' '.repeat(Math.max(1, gap)) + r;
}

// Format a score amount with sign
function fmtAmt(n) {
  if (n == null || n === '') return '';
  const abs = Math.abs(Math.round(n));
  const sign = n >= 0 ? '+' : '-';
  return sign + abs.toLocaleString();
}

// Section name for grouping
function _txSection(evType) {
  if (!evType) return 'OTHER';
  if (evType === 'atari-og')           return 'EASTER EGG BONUS';
  if (evType === 'super-clear')        return 'SUPER BONUS';
  if (evType.startsWith('line-'))      return 'LINE CLEAR AWARDS';
  if (evType === 'tetris')             return 'TETRIS BONUS';
  return 'MISC';
}

// â”€â”€ Build receipt DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildReceiptDOM() {
  const root = document.getElementById('receipt-content');
  if(!root){ dbg('ERR: receipt-content not found'); return; }
  try {
    root.innerHTML = '';
  } catch(e) { dbg('ERR clearing receipt: '+e.message); return; }
  const A = el => { try{ root.appendChild(el); }catch(e){ dbg('ERR append: '+e.message); } };

  try {

  const L  = (t,o)  => A(dmLine(t, o));
  const SP = (px)   => A(dmSpacer(px));
  const HR = (c,n)  => L((c||'=').repeat(n||DM_COLS));

  // \u2500\u2500 HEADER \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
  SP(10);
  L(center('HIGHTOWER DISTRICT'), {inv:true, bold:true});
  SP(2);
  L(center('777 OLIVE AVE'));
  L(center('FRESNO  CA  93728'));
  L(center('(559) 485-9050'));
  SP(4);
  HR('=');
  L(center('CELLTOWER  GAME  RECEIPT'));
  L(center(new Date().toLocaleDateString('en-US',
    {weekday:'short',month:'short',day:'2-digit',year:'numeric'})));
  L(center(new Date().toLocaleTimeString()));
  HR('=');
  SP(4);
  L('  CASHIER: HIGHTOWER AI');
  L('  REGISTER: CLAUDE SONNET');
  HR('-');
  SP(2);

  // \u2500\u2500 TRANSACTIONS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
  let sectionRunningBase = 0;
  let currentSection = '';
  let sectionTotal = 0;
  let grandRunning = 0;

  const openSection = (name) => {
    if (currentSection) closeSection();
    currentSection = name;
    sectionRunningBase = grandRunning;
    sectionTotal = 0;
    SP(3);
    HR('-');
    L('  ** ' + name + ' **', {bold:true});
    HR('-');
  };

  const closeSection = () => {
    if (!currentSection) return;
    HR('.');
    L(dmRow('  SUBTOTAL  ' + currentSection, fmtAmt(sectionTotal)));
    grandRunning += sectionTotal;
    L(dmRow('  RUNNING TOTAL', '='+grandRunning.toLocaleString()));
    sectionTotal = 0;
    currentSection = '';
  };

  // Session start line
  const startEntry = txLog.find(t => t.type === 'session-start');
  if (startEntry) {
    L('  SESSION OPENED');
    L('  ' + new Date(startEntry.ts).toLocaleTimeString());
    SP(2);
  }

  // Score events
  const scored = txLog.filter(t => t.type === 'score');

  if (scored.length === 0) {
    SP(6);
    L(center('-- NO SCORES YET --'));
    L(center('PLAY A GAME FIRST!'));
    SP(6);
  } else {
    scored.forEach((tx, idx) => {
      const section = _txSection(tx.eventType);
      if (section !== currentSection) openSection(section);

      // Main line
      const desc = _txDesc(tx);
      L(dmRow('  ' + desc, fmtAmt(tx.amount)));
      sectionTotal += tx.amount;

      // Sub-lines (like CRV breakdown)
      if (tx.breakdown && tx.breakdown.length) {
        tx.breakdown.forEach(b => {
          const val = b.value != null ? String(b.value) : '';
          L(dmRow('    ' + b.label, val));
        });
      }
    });
    closeSection();
  }

  SP(4);
  HR('=');
  // \u2500\u2500 TOTALS SUMMARY \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
  L(dmRow('  LINES CLEARED',   String(lines)));
  L(dmRow('  LEVEL REACHED',   String(level)));
  L(dmRow('  PIECES PLACED',   String(piecesPlaced)));
  L(dmRow('  HOLE FREE RUN',   currentScoringHoles===0 ? 'YES' : 'NO'));
  HR('-');
  L(dmRow('  SUBTOTAL',        score.toLocaleString()));
  L(dmRow('  TAX / FEES',      'N/A'));
  HR('=');
  SP(2);
  L(dmRow('  *** TOTAL ***', score.toLocaleString()), {inv:true, bold:true});
  SP(2);
  L(dmRow('  HIGH SCORE',      hi.toLocaleString()));
  HR('=');
  SP(6);

  // \u2500\u2500 FOOTER \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
  L(center('"Get high at the Tower"'));
  SP(2);
  L(center('-- THC Magazine *'));
  SP(6);
  HR('-');
  L('  * THC MAGAZINE IS A WHOLLY');
  L('    FICTITIOUS PUBLICATION.');
  L('    ANY RESEMBLANCE TO ACTUAL');
  L('    PERIODICALS IS COINCIDENTAL');
  L('    AND PROBABLY DOPE.');
  HR('-');
  SP(4);
  L(center('PRODUCED BY'));
  L(center('ANTHROPIC CLAUDE AI'));
  L(center('CLAUDE.AI'));
  SP(4);
  HR('~');
  L(center('THANK YOU FOR PLAYING!'));
  L(center('COME BACK SOON'));
  HR('~');
  SP(4);

  // Barcode decoration
  const bc = '||| | || ||| | | || ||| | || | ||| | |';
  L(bc.substring(0,DM_COLS));
  SP(2);
  L(center(Date.now().toString(36).toUpperCase()));
  SP(12);
  } catch(e) { dbg('ERR buildReceipt: '+e.message+' '+(e.stack ? e.stack.split('\n')[1] : '')); }
}

function center(txt) {
  const t = String(txt).substring(0, DM_COLS);
  const pad = Math.max(0, Math.floor((DM_COLS - t.length) / 2));
  return ' '.repeat(pad) + t;
}

function _txDesc(tx) {
  const e = tx.eventType || '';
  if (e === 'atari-og')     return 'ATARI OG BONUS: 20,490';
  if (e === 'line-1')       return '1-LINE CLEAR AWARD';
  if (e === 'line-2')       return '2-LINE CLEAR AWARD';
  if (e === 'line-3')       return '3-LINE CLEAR AWARD';
  if (e === 'line-1-blocked') return '1-LINE BLOCKED (10+ HOLES)';
  if (e === 'line-2-blocked') return '2-LINE BLOCKED';
  if (e === 'line-3-blocked') return '3-LINE BLOCKED';
  if (e === 'tetris')       return 'TETRIS! 4-LINE BONUS';
  if (e === 'super-clear')  return 'PERFECT CLEAR: 20,490';
  return tx.desc || e.toUpperCase();
}

function showReceipt() {
  try {
    dbg('showReceipt: txLog='+txLog.length);
    buildReceiptDOM();
    const root = document.getElementById('receipt-content');
    dbg('receipt-content children: '+(root?root.children.length:'NULL'));
    const ov = document.getElementById('receipt-overlay');
    dbg('receipt-overlay: '+(ov?'found':'NULL'));
    if(ov){ ov.classList.add('show'); }
    const sc = document.getElementById('receipt-scroll');
    if(sc){ requestAnimationFrame(()=>requestAnimationFrame(()=>{ sc.scrollTop=sc.scrollHeight; })); }
  } catch(e) { dbg('ERR showReceipt: '+e.message); }
  _receiptOpen = false;
}

function hideReceipt() {
  const ov = document.getElementById('receipt-overlay');
  if(ov) ov.classList.remove('show');
  _receiptOpen = false;
}


// Single-canvas startup
window.addEventListener('DOMContentLoaded', function(){
  try {
    dbg('DOM ready...');
    // Paint something immediately so we know canvas is alive
    const cv2 = document.getElementById('cv');
    if(cv2){
      cv2.width = window.innerWidth || 390;
      cv2.height = window.innerHeight || 693;
      const ctx2 = cv2.getContext('2d');
      ctx2.fillStyle='#080018';
      ctx2.fillRect(0,0,cv2.width,cv2.height);
      ctx2.fillStyle='#00ff88';
      ctx2.font='bold 14px monospace';
      ctx2.textAlign='center';
      ctx2.fillText('Loading...', cv2.width/2, cv2.height/2);
    }
    resize();
    dbg('SW='+SW+' SH='+SH+' CELL='+CELL+' Rgx='+R.gx);
    layout();
    _syncAutoUI();
    dbg('init done, starting loop');
    requestAnimationFrame(loop);
  } catch(e) {
    // Last resort â€” draw error directly on canvas
    const cv2 = document.getElementById('cv');
    if(cv2){
      const ctx2 = cv2.getContext('2d');
      ctx2.fillStyle='#500';
      ctx2.fillRect(0,0,cv2.width||390,80);
      ctx2.fillStyle='#fff';
      ctx2.font='12px monospace';
      ctx2.textAlign='left';
      ctx2.fillText('STARTUP ERR: '+e.message, 6, 20);
      ctx2.fillText(e.stack ? e.stack.split('\n')[1] : '', 6, 40);
    }
  }
});
window.addEventListener('resize', function(){ resize(); layout(); });

</script>

</body>
</html>